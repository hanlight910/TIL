---
id: "7576"
aliases: []
tags:
  - bfs
  - graph_traverse
ref:
  - https://www.acmicpc.net/problem/7576
---
# 💳 문제이해

N x M 격자로 이루어진 토마토 밭이 주어졌습니다. 토마트들 중 않은 것은 
1, 익지 않은 것은 0, 토마토가 들어있지 않는 칸은 -1로 표현합니다.

- 익은 토마토: 1
- 익지 않은 토마토: 0
- 토마토가 없는 칸: -1

익은 토마토를 기준으로 왼쪽, 오른쪽, 앞, 뒤 칸이 하루가 지나면
익지 않은 토마토는 익은 토마토가 됩니다. 격자 안에 모든 토마토가
익을려면 최소 며칠이 필요한지 구하시오. 단, 모든 토마토가 결과적으로
익지 않은 경우에는 -1을 출력하시오.

# 🚥 문제접근

`BFS` 알고리즘은 가중치가 작은 수라면, 가장 짧은 경로를 구하는 
문제에 적합한 방법입니다. 다만 해당 방법으로 모든 원소를 탐색하지는
못할 것 같습니다. 토마토가 없는 칸은 지나갈 수가 없어요. 이렇게 된다면,
`BRUTE FORCE`로 전 탐색을 하거나, `BFS`로직을 수정하는 수 밖에 없네요.
단, `BRUTE FORCE`를 소요 시간을 $O(n * m)$ 가집니다.


## 🌏 분석

하나의 익은 토마토만이 아닌 여러개의 익은 토마토가 동시적으로 
인접한 익지 않은 토마토를 익게 만드는 것입니다. 따라서, 일 수를 어떻게 세면 
좋을 까요. 우선은 BFS로 나올 수 있는 일 수를 전부 계산한 뒤에, 나중에
나오는 익은 토마토를 기준으로 다시 계산한 일 수에서 원래 일수를 빼는 방식은 
안 될까요?

**예시**:
```
6 4
1 -1 0 0 0 0
0 -1 0 0 0 0
0 0 0 0 -1 0
0 0 0 0 -1 1
```
아래에서 가장 오른쪽에 있는 1이 0이면, 나올 수 있는 최소 일수는 
9일이(머리로 센거) 걸립니다. 하지만 원래 자리에 1이 있다면, 6일이 걸립니다.
전자를 구현하기는 쉽지만, 후자를 어떻게 해야 할지 고민입니다.

관건은 동시적으로 구현을 어떤 방식으로 해야 하는지인데, 정석은 모든
토마토의 자표를 구해서 모두 동시적으로 해결하는 거죠. 

###  🌂 BFS

그래프/트리에서 깊이가 아닌 너비를 우선적으로 탐색하는 방법입니다.
같은 깊이를 동시적으로 탐색하는 특성을 가지므로, 가중치가 작으면
가장 짧은 경로를 구할 때 적절한 알고리즘입니다.

여기서 깊이/단계는 일 수를 의미하며, 우선 모든 토마토가 익은 좌표를
큐에 우선적으로 넣습니다. 그러면 각 익은 토마토를 기준으로 동시적으로
익지 않은 토마토를 추적할 수 있습니다.

원하는 위치의 처음으로 도달한 경우가 최단 최단 경로임을 보장합니다.
혹은 마지막에 큐에 남아 있는 겨우가 최단 경로입니다

아니면 전체 노드가 모두 탐색된 경우를 찾으시면, 탐색한 경로의
수에서 가장 큰 값이 최장 경로입니다.

이는 각 노드가 처음 방문한 경로가 최단 경로를 갖는 것을 보장하는 `BFS`의
특성입니다.

### 🥖 Brute force Search

모든 경우의 수를 탐색할 때 사용하는 방법입니다. 

이걸로 익은 모든 토마토의 위치를 구합니다. 그리고 마지막에 모든
칸이 익은 토마토가 있는 확인합니다. 아니면, -1을 출력합니다.

#### 🖥️ source code

**C**:

```c
#include<stdio.h>
#include<stdint.h>
#include<stdlib.h>

#define DEFINE_DIRECTIONS(name) int32_t name[4][2] = { { 0, -1 }, { 0, 1 }, { -1, 0 }, { 1, 0} }

typedef struct {
    int32_t** visited;
    int32_t** dist;
    int32_t max_row;
    int32_t max_col;
    int32_t min_row;
    int32_t min_col;
} Graph;

typedef struct {
    int32_t row;
    int32_t col;
} Data;

typedef struct Node {
    Data val;
    struct Node* next;
    struct Node* head;
} queue;

queue* enqueue(queue* q, Data val) {
    queue* new_q = (queue*)malloc(sizeof(queue));
    new_q->val = val;
    new_q->next = NULL;

    if (q == NULL) {
        new_q->head = new_q;
    } else {
        q->next = new_q;
        new_q->head = q->head;
    }

    return new_q;
}

Data dequeue(queue** q) {
    Data return_val;
    if (*q != NULL) {
        return_val = (*q)->head->val;
        queue* temp = (*q)->head;
        if (((*q)->head && ((*q)->head->next == NULL))) {
            (*q) = NULL; 
        } else {
            (*q)->head = (*q)->head->next;
        }
    }
    return return_val;
} 

_Bool is_valid(Graph* g, Data cord) {
    if (g->max_row > cord.row && cord.row >= g->min_row 
        && (g->max_col > cord.col && cord.col >= g->min_col)) {
        if (!g->visited[cord.row][cord.col] && g->visited[cord.row][cord.col] != -1) {
            return 1;
        }
    }
    return 0;
}

int32_t bfs(Graph g, queue* valid_tomatoes) {
    int32_t max_count = 0;
	DEFINE_DIRECTIONS(direction);
    if (valid_tomatoes == NULL) {
        return 0;
    }

    queue* q = valid_tomatoes;

    while (q != NULL) {
        Data cur = dequeue(&q);
        
        for (int32_t i = 0; i < 4; i += 1) {
            Data dir_cur = {
                cur.row + direction[i][0],
                cur.col + direction[i][1],
            };

            if (is_valid(&g, dir_cur)) {
                g.visited[dir_cur.row][dir_cur.col] = 1;
				q = enqueue(q, dir_cur);
				g.dist[dir_cur.row][dir_cur.col] = g.dist[cur.row][cur.col] + 1;
				if (max_count < g.dist[dir_cur.row][dir_cur.col]) {
					max_count = g.dist[dir_cur.row][dir_cur.col];
				}
            }
        }
    }

    return max_count;
}

int32_t main(void) {
    int32_t M, N;
    scanf("%d %d", &M, &N);
    Graph g = {
        .visited = (int32_t**)malloc(N * sizeof(int32_t*)),
        .dist = (int32_t**)malloc(N * sizeof(int32_t*)),
        .max_row = N,
        .max_col = M,
        .min_col = 0,
        .min_row = 0,
    };

    for (int32_t i = 0; i < N; i += 1) {
        g.visited[i] = (int32_t*)calloc(M, sizeof(int32_t));
        g.dist[i] = (int32_t*)calloc(M, sizeof(int32_t));
        for (int32_t j = 0; j < M; j += 1) {
            scanf("%d", &g.visited[i][j]);
        }
    }

    queue* new_q = NULL;
    int32_t cnt_of_valid_tomatoes = 0;
    for (int i = 0; i < N; i += 1) {
        for (int j = 0; j < M; j += 1) {
            if (g.visited[i][j] != -1) {
                cnt_of_valid_tomatoes += 1;
            }
            if (g.visited[i][j] == 1) {
                Data val = { i, j };
                new_q = enqueue(new_q, val);
            } 
        }
    }
    int32_t count = bfs(g, new_q);

	int32_t valid_cnt = 0;
	for (int i = 0; i < N; i += 1) {
		for (int j = 0; j < M; j += 1) {
			if (g.visited[i][j] == 1) {
				valid_cnt += 1;
			}
		}
	}
	// printf("valid_tomatoes: %d\n", cnt_of_valid_tomatoes);
	// printf("count: %d\n", count);
    cnt_of_valid_tomatoes == valid_cnt ? printf("%d\n", count) : printf("-1");
     
    return 0;
}
```
