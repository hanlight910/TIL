---
id: "1260"
aliases: []
tags: []
---

# ğŸ’³ ë¬¸ì œì´í•´

`N`ê°œì˜ ì •ì ì´ê³¼ `M`ê°œì˜ ê°„ì„ ì´ ì£¼ì–´ì§€ë©´, ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ dfsì™€ bfsë¥¼ íƒìƒ‰í•œ
ìˆœì„ ëŒ€ë¡œ ì¶œë ¥í•˜ì‹œì˜¤.

# ğŸš¥ ë¬¸ì œì ‘ê·¼

`dfs`ì™€`bfs` ì•Œê³ ë¦¬ì¦˜ì„ êµ¬í˜„í•  ì¤„ ì•Œë©´ ì–´ë ¤ìš´ ë¬¸ì œëŠ” ì•„ë‹™ë‹ˆë‹¤.

## ğŸ› ï¸ í’€ì´

```mermaid
flowchart TD
id1[1] --- id2[2] & id3[3] & id4[4]
id2 --- id4
id3 --- id4
```

### âšœï¸  dfs(depth-first search)

ê¹Šì´ë¥¼ ìš°ì„ ìœ¼ë¡œ ë„ˆë¹„ë³´ë‹¤ ìš°ì„ ì ìœ¼ë¡œ íƒìƒ‰ë˜ì–´ì•¼ í•©ë‹ˆë‹¤. ì¬ê·€ì ìœ¼ë¡œ êµ¬í˜„í•˜ê±°ë‚˜,
ë‚˜ì¤‘ì— ë“¤ì–´ì˜¤ëŠ” ì›ì†Œë¥¼ ìš°ì„ ì ìœ¼ë¡œ ì²˜ë¦¬í•˜ëŠ” `stack`ì„ ì‚¬ìš©í•˜ì—¬ êµ¬í˜„ í•  ìˆ˜ 
ìˆìŠµë‹ˆë‹¤. ë‹¤ë§Œ ìŠ¤íƒì€ ì •ë°˜ëŒ€ì˜ ìˆœì„œë¡œ ì›ì†Œë“¤ì„ ì²˜ë¦¬í•©ë‹ˆë‹¤.

### ğŸ’  bfs(breadth-first search)

ë„ˆë¹„ë¥¼ ìš°ì„ ìœ¼ë¡œ íƒìƒ‰í•©ë‹ˆë‹¤. `brute force`ë¥¼ ì‚¬ìš©í•´ì„œ íƒìƒ‰í•  ìˆ˜ë„ ìˆê² ì§€ë§Œ,
ê° ë…¸ë“œì˜ ì¸ì ‘í•œ ë…¸ë“œë“¤ì„ íŒŒì•… í•  ìˆ˜ ê°€ ì—†ì–´, ìë£Œ êµ¬ì¡° `queue`ë¥¼ êµ¬í˜„í•˜ì—¬
`dfs`ì™€ ëŒ€ë¹„ì ìœ¼ë¡œ ë¨¼ì € ë“¤ì–´ì˜¤ëŠ” ì›ì†Œë¥¼ ì²˜ë¦¬í•©ë‹ˆë‹¤.

### ğŸ–¥ï¸ source code

```c
#include<stdio.h>
#include<stdint.h>
#include<stdlib.h>

#define new_node()((Node*)malloc(sizeof(Node)))

typedef struct Node {
    int32_t data;
    struct Node* next;
} Node;

typedef struct Graph {
    Node** adj_list;
    int32_t num_vertices;
} Graph;

typedef struct queue {
	int32_t data;
	struct queue* next;
	struct queue* head;
} queue;

typedef struct stack {
	int32_t data;
	struct stack* back;
	struct stack* next;
} stack;

stack* push(stack* a, int32_t val) {
	stack* new = (stack*)malloc(sizeof(stack));
	new->next = NULL;
	new->back = NULL;
	new->data = val;
	if (a == NULL) {
		a = new;
	} else {
		new->back = a;
		a->next = new;
		a = new;
	}
	return a;
}

stack* pop(stack* a) {
	if (a != NULL) {
		if (a->back == NULL) {
			free(a);
			return NULL;
		} else {
			a->back->next = a->next;
			stack *temp = a->back;
			free(a);
			return temp;
		}
	}
	return NULL;
}
int32_t create_queue(queue** q, int32_t val) {
	if (*q == NULL) {
		*q = (queue*)malloc(sizeof(queue));;
		(**q).next = NULL;
		(**q).data = val;
		(**q).head = (*q);
	}
	return 0;
} 

int32_t enqueue(queue** q, int32_t val) {
	if (*q == NULL) {
		create_queue(q, val);
	} else {
		queue* new_node = (queue*)malloc(sizeof(queue));
		new_node->next = (*q)->next;
		new_node->data = val;
		new_node->head = (**q).head;
		(**q).next = new_node;
		(*q) = new_node;
	}
	return 0;
}

int32_t dequeue(queue** q) {
	if (*q != NULL && (**q).head != NULL) {
		queue* temp = (*q)->head;
		(*q)->head = (**q).head->next;
		if (temp->next == NULL) {
			(*q) = NULL;
		}
		free(temp);
	}
	return 0;
}

Node* create_node(int32_t val) {
    Node* new_node = (Node*)malloc(1 * sizeof(Node));
    (*new_node).next = NULL;
    (*new_node).data = val;
    return new_node;
}

Graph* create_graph(int32_t num_vertices) {
    Graph* new_graph = (Graph*)malloc(1 * sizeof(Graph));
    (*new_graph).num_vertices = num_vertices;
    (*new_graph).adj_list = (Node**)malloc((num_vertices + 1) * sizeof(Node*));
    for (int i = 1; i <= num_vertices; i += 1) {
        (*new_graph).adj_list[i] = NULL;
    }
    return new_graph;
}

void insert_vertex(Graph* g, int32_t src, int32_t dst) {
	Node* src_node = create_node(dst);
	Node* current;
	if (*((*g).adj_list + src) == NULL || g->adj_list[src]->data >= dst) {
		src_node->next = *((*g).adj_list + src);
		*((*g).adj_list + src) = src_node;
	} else {
		current = g->adj_list[src];
		while (current->next != NULL && current->next->data < dst) {
			current = current->next;	
		}
		src_node->next = current->next;	
		current->next = src_node;
	}
	return;
}

void add_edge(Graph* g, int32_t src, int32_t dst) {
	insert_vertex(g, src, dst);	
	insert_vertex(g, dst, src);	
	return;
}

void print_dfs(Graph* g, int32_t R, int32_t* visited)  {
	if (visited[R]) {
		return;
	}
	printf("%d ", R);
	visited[R] = 1;
	Node* head_of_r = g->adj_list[R];
	while (head_of_r != NULL) {
		int32_t data = head_of_r->data;
		if (!visited[data]) {
			print_dfs(g, data, visited);
		}
		head_of_r = head_of_r->next;
	}
	return;
}

void print_bfs(Graph* g, int32_t R, int32_t N) {
	int32_t* visited = (int32_t*)calloc((N + 1), sizeof(int32_t));
	queue* q = NULL;
	create_queue(&q, R);
	visited[R] = 1;
	printf("%d ", R);
	while (q != NULL && q->head != NULL) {
		Node* head_of_r = g->adj_list[q->head->data];
		dequeue(&q);
		while (head_of_r != NULL) {
			int32_t data = head_of_r->data;
			if (!visited[data]) {
				visited[data] = 1;
				enqueue(&q, data);		
				printf("%d ", data);
			}
			head_of_r = head_of_r->next;
		}
	}	
	printf("\n");
	return;
}

int32_t main(void) {
    int32_t N, M, R;
	scanf("%d %d %d", &N, &M, &R);
	Graph* g = create_graph(N);
	for (int32_t i = 0; i < M; i += 1) {
		int32_t u, v;
		scanf("%d %d", &u, &v);
		add_edge(g, u, v);
	}
	int32_t* visited = (int32_t*)calloc((N + 1), sizeof(int32_t));
	print_dfs(g, R, visited);
	printf("\n");
	print_bfs(g, R, N);
	return 0;
}
```
