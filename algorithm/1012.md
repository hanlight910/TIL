---
id: "1012"
aliases: []
tags: []
---

# 💳 문제이해

가로 길이 M과 세로 길이 N의 행렬(matrix)가 주어졌을 때, 각 원소는 0 혹은 
1로 구성되어 있습니다. 1로 연결된 구역의 개수를 구합니다.

# 🚥 문제접근

이전에 풀었던 연결된 구역의 개수를 구하는 문제와 유사합니다.
[2667](06-DAILY/TIL/algorithm/2667.md)

1. `DFS`나 `BFS`를 사용하여 연결된 구역을 찾습니다.
2. 연결된 구역을 찾으면 개수를 증감합니다.
3. 모든 원소를 탐색해야 하므로 `brute force` 방식으로 완전 탐색을 수행합니다.
4. 현재 원소가 1이면서 아직 방문하지 않았다면, 1단계를 시작합니다.

## 🛠️ 풀이

### ⚜️  DFS(Depth-First Search)

너비보다 깊이를 우선적으로 탐색하는 방식, 가능한 깊이까지 탐색을 시도한 이후,
더 이상 탐색할 곳이 없으면 되돌아오면서 다른 경로를 탐색하는 방식. `stack`이나
재귀적으로 구현 할 수 있습니다. 이는 나중에 들어오는 원소를 우선적으로 
처리하기 위하여 사용되는 방식입니다.

### 🥖 Brute Force

완전 탐색 

#### 🖥️ source code

```c
#include<stdio.h>
#include<stdint.h>
#include<stdlib.h>

typedef struct {
    int32_t** graph;
    int32_t** visited;
    const int32_t* max_row;
    const int32_t* max_col;
    const int32_t* min_row;
    const int32_t* min_col;
} Graph;

typedef struct {
    int32_t row;
    int32_t col;
} coord;

typedef struct Node {
    coord data;
    struct Node* next;
    struct Node* prev;
} Node;

typedef Node stack;

coord push(stack** a, coord val) {
    stack* new = (stack*)malloc(sizeof(stack));
        (*new).data = val;
        (*new).next = NULL;
        (*new).prev = (*a);
    if (*a == NULL) {
        (*a) = new; 
    } else {
        (*a) = new;
    }
    return val;
}
int32_t is_empty(stack* a) {
    return a == NULL ? 1 : 0;
}

coord pop(stack** a) {
    if ((*a) == NULL) {
		coord c;
        return c;
    }
    stack* tmp = (*a);
    coord val = tmp->data;
	if ((**a).prev != NULL) {
		(**a).prev->next = (**a).next;
	}
    (*a) = (**a).prev;
    free(tmp);
    return val;
}

int32_t is_valid(Graph* g, int32_t row, int32_t col) {
    if ((*g->max_row > row && *g->min_row <= row) &&
        (*g->max_col > col && *g->min_col <= col)) {
        if (g->graph[row][col] && !g->visited[row][col]) {
            return 1;
        }
    }
    return 0;
}

int32_t dfs(Graph a, int32_t row, int32_t col) {
    stack* s = NULL;
    coord c = { row, col };
    int32_t directions[2][4] = {
        { 0, 0, -1 , 1 },
        { -1, 1, 0, 0 },
    };
    push(&s, c);
    a.visited[row][col] = 1;

    while (s != NULL) {
        coord tmp_c = pop(&s);
        for (int32_t i = 0; i < 4; i += 1) {
            coord tmp_c_dr = { tmp_c.row + directions[0][i], tmp_c.col + 
            directions[1][i] };
            if (is_valid(&a, tmp_c_dr.row, tmp_c_dr.col)) {
				// printf("row: %d; col: %d\n", tmp_c_dr.row, tmp_c_dr.col);
                push(&s, tmp_c_dr);
                a.visited[tmp_c_dr.row][tmp_c_dr.col] = 1;
            }
        }
    }

    return 1;
}
int32_t main(void) {
    int32_t T;
    scanf("%d", &T);

    for (int32_t i = 0; i < T; i += 1) {
        int32_t N, M, K;
        scanf("%d %d %d", &N, &M, &K);
        int32_t min_row = 0, min_col = 0;
		int32_t cnt = 0;
        Graph a = {
            .visited = (int32_t**)malloc((N) * sizeof(int32_t*)),
            .graph = (int32_t**)malloc((N) * sizeof(int32_t*)),
            .max_row = &N,
            .max_col = &M,
            .min_row = &min_row,
            .min_col = &min_col,
        };
        for (int32_t i = 0; i < N; i += 1) {
            a.visited[i] = (int32_t*)calloc(M, sizeof(int32_t));
            a.graph[i] = (int32_t*)calloc(M, sizeof(int32_t));
        }
        for (int32_t i = 0; i < K; i += 1) {
            int32_t row, col;
            scanf("%d %d", &row, &col);
            a.graph[row][col] = 1; 
        }
        for (int32_t i = 0; i < N; i += 1) {
            for (int32_t j = 0; j < M; j += 1) {
                if (a.graph[i][j] && !a.visited[i][j]) {
					// printf("y: %d; x: %d; cnt: %d\n", i, j, cnt);
                    cnt += dfs(a, i, j);
                }
            }
        }
		for (int32_t i = 0; i < N; i += 1) {
			free(a.graph[i]);
			free(a.visited[i]);
		}
		free(a.graph);
		free(a.visited);
        printf("%d\n", cnt);
    }
    
    return 0;
}
``` 

### 🎑 후기

[2667](https://www.acmicpc.net/problem/2667)
문제의 연장선인 거 같습니다.
