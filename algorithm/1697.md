---
id: "1697"
aliases: []
tags: []
---

# 💳 문제이해

위치를 나타내는 N이 주어지고 목표의 이취를 나타내는 K도 주어진다.
각 횟수마다 N의 위치인 X는 X - 1 또는 X + 1로 이동할 수 있다.
혹은 2 * X를 할 수도 있다. 위 방법을 사용하여 K까지 도달하기 위한
최소 횟수를 구하시오.

# 🚥 문제접근

예시를 통해 구체적으로 살펴봅니다.

**예시**:
```
5 17
```

```mermaid
5 --> 10 --> 9 --> 18 --> 17
```

1. 5를 2번 곱하고 10으로 이동합니다.
2. 10에서 1을 빼 9로 이동합니다.
3. 9를 두 번 곱해 18로 이동합니다.
4. 18에서 1을 빼면 목표인 17로 이동이 가능합니다.

왠지 느낌상 동적 프로그래밍이 가능할 것 같은 느낌이군요.

해당 문제는 모든 경우의 수를 탐색하는 문제인 것 같습니다.
그 경우의 수에서 최소 경로를 찾는 거고요.

그래프로 말한다면, 양방향 그래프 간선은 1입니다.

우선 bfs로 그롤 풀어 보겟습니다.

`노드` 5에서 가능한 수는 5 + 1, 5 - 1, 5 * 2 와 같이 3가지 경우의 수가
있습니다. 해당 이웃 간선에서 또 다음 간선으로 넘어가는 식으로 풀면,
풀 수 있을 겁니다.. 아마도.

1. 5 + 1 = 6 경우
    1. 6 + 1 = 6
    2. 6 - 1 = 5 는 이미 탐색하였으므로, 스킵합니다.
    3. 6 * 2 = 12
2. 5 - 1 = 4 경우
    ...

참고로 목표가 100,000 이고 값이 50,001 이 주어졌을 때는
굳이 2를 곱하고 1을 두 번 빼지 않아도, 1을 빼고 2를 곱해도 됩니다.
즉슨 범위는 100,00까지입니다.

- 50,001 * 2 + 1 - 1 = 100,000
- (50,000 - 1) * 2 = 100,000

## 🛠️ 풀이

### 🖥️ source code

```c
#include<stdio.h>
#include<stdint.h>

typedef struct {
    uint32_t* arr;
    uint32_t* visited;
    uint32_t* dist;
    uint32_t max;
    uint32_t min;
} Graph; 

typedef struct Node {
    int32_t data;
    struct Node* next;
    struct Node* head;
} queue;

queue* enqueue(queue* q, int32_t value) {
    queue* new_q = (queue*)malloc(sizeof(queue));
    new_q->data = value;
    new_q->next = NULL;
    if (q == NULL) {
        new_q->head = new_q;
    } else {
        q->next = new_q;
        new_q->head = q->head;
    }
    return new_q;
}
int32_t dequeue(queue** q) {
    int32_t val;

    if (*q == NULL) {
        return 0;
    } else {
        val = (**q).head->value;
        queue* tmp = head;
        (**q).head = (**q).head->next;
        free(tmp);
    }
    return val;
}

int32_t apply_operation(int32_t num, int32_t idx) {
    if (idx == -1) {
        return num - 1; 
    } else if (idx == 1) {
        return num + 1;
    } else {
        return num * 2;
    }
}

int32_t is_valid(Graph* g, int32_t idx) {
    if (idx >= g->min && idx < g->max) {
        if (!g->visited[idx]) {
            return 1;    
        }
    }
    return 0;
}

int32_t bfs(Graph g, int32_t start, int32_t target) {

    int32_t operation[3] = {
        -1, 1, 2,
    };

    queue* q = NULL;

    q = push(q, start);

    g.visited[start] = 1;
    g.dist[start] = 0;

    while (q != NULL) {
        int32_t val = pop(&q);

        for (int32_t i = 0; i < 3; i += 1) {
            int32_t cur_val = apply_operation(val, operation[i]);
            if (is_valid(g, cur_val)) {
                q = push(q, cur_val);
                g.dist[cur_val] = g.dist[val] + 1;
                g.visited[cur_val] = 1;
                if (cur_val == target) {
                    return g.dist[target];
                }
            }
        }     
    }
    
    return g.dist[target];
}

int32_t main(void) {
    uint32_t N, K;
    scanf("%d %d", &N, &K);

    Graph g = {
        .arr = (int32_t*)calloc(N, 200001),
        .visited = (int32_t*)calloc(N, 200001),
        .dist = (int32_t*)calloc(N, 200001),
        max = 200001,
        min = 0,
    };
    int32_t min_path = bfs(g, N, K);
    printf("%d\n", min_path);

    return 0;
}
```
