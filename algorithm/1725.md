---
id: "1725"
aliases:
  - 히스토그램
tags:
  - 히스토그램
  - 스택
ref:
  - https://www.acmicpc.net/problem/1725
---

# 💳 문제이해

각 높이가 주어지는 직사각하형 N개가 주어졌을 때, 각 직사각형이 순서 되로
나열 되었을 때, 이어지는 가장 큰 직사각형의 넓이를 구하세요.

# 🚥 문제접근

히스토그램이 주어졌을 때, 가장 큰 직사각형을 구하는 문제, 전에 
스택 파트에서 푼 기억이 있습니다.

검색해보니, 풀이를 작성하지 않는 걸로 보아 정답만 보고, 제출 했을 가능성이
높습니다.

## 🛠️ 문제분석

이번 문제는 가장 높은 막대를 추적 할 수 있는 스택을 사용하는 것이 적절
할 것입니다. 

### 🌏 예시

```
4 2 1 4 5 1 3 3
```
가 주어졌을 때,

스택을 저장하였을 때, 이전 원소가 현재 원보다 크거나, 작을 경우입니다.

1. 스택이 비어 있으니 우선 4를 넣습니다.  
2. 2도 우선 넣어봅니다.  
생각해보니 2를 넣으면 더 이상 높이 4의 막대는 높이 2 이상은 못 쓰니 쓸모가 없네요.
여기서 넓이를 구합니다. 2 x 2 = 4
3. 1을 넣습니다.  
현재 넓이는 3 x 1 = 3 입니다. 우선 4가 크므로 4를 최대 넓이로서 저장합니다.
4. 4를 넣습니다.  
현재 넓이는 4 x 1 = 4 입니다.
5. 5를 넣습니다.  
현재 넓이는 2 x 4 = 8입니다.
6. 1을 넣습니다.  
현재 넓이는 5 x 1 = 5입니다. 8이 더 크므로 8을 최대 넓이로서 저장합니다.
7. 3을 넣습니다.
현재 넓이는 7 x 1 = 7입니다. 8이 더 크므로 8을 최대 넓이로서 저장합니다.
8. 3을 넣습니다. 
현재 넓이는 2 x 3 = 6입니다. 8이 더 크므로 8을 최대 넓이로서 저장합니다.

계속해서 최대 넓이를 추적하면 될 거 같습니다.

아마도...

### ♻️  문제해결

나올 수 오는 경우의 수는 이전 원소보다 크거나 작거나입니다.

1. 이전 원소가 현재 원소보다 더 클 경우, 현재 원소의 높이가 현재 넓이의
필요한 높이입니다. 그러면 너비는 어떻게 구할까요? 위에 조건이 높이를 구하는
조건이라면, 스택에 쌓이는 순서는 오름차순일 것입니다. 따라서 그러지 않을 경우는,
모든 막대기에 너비가 1이라는 것을 감안하면 현재 인덱스에서 이전 원소의 
인덱스에서 뺀 값이 너비 입니다.

- 1, 2, 3

1. 우선 1을 스택에 넣습니다.  
2. 2는 1보다 큽니다. 따라서 그냥 넣습니다.
3. 3은 2보다 큽니다. 따라서 그냥 넣습니다.

모든 원소를 순회 하였으면, 남아 있는 원소들을 처리합니다. 이 때 
인덱스는 N입니다.
1. 3의 인덱스는 3입니다
    - 높이: 3
    - 너비: 현재 인덱스 - 이전 원소의 인덱스 - 1 = 1
    - 넓이: 3 * 1 = 3
2. 2의 인덱스는 3입니다.
    - 높이: 2
    - 너비: 3 - 0 - 1 = 2
    - 넓이: 2 * 2 = 4
3. 3의 인덱스는 3입니다.
    - 높이: 1
    - 너비: 쌓아놓은 원소가 이제 없으니 인데스가 너비입니다. 3  
    이는 모든 막대기가 해당 높이 이상이라는 소리입니다. (3 > 2 > 1)
    - 넓이: 1 * 3 = 3

결론 4가 가장 넓은 넓이므로 4를 출력합니다.
- 1, 3, 2

1. 비어 있으니 1을 넣습니다.
2. 3은 1보다 크니 그냥 넣습니다.
3. 2는 3보다 작으니 넓이를 구합니다.  
3은 이제 필요 없으니 3을 제거합니다.
    - 높이: 2(현재 원소의 높이 입니다.)
    - 너비: 1(현재 인덱스 - 이전 인덱스 - 1) = 2 - 0 - 1   
    이전 인덱스가 0인 이유는 첫 번째 원소인 1이 인덱스가 0이기 때문입니다.
    - 넓이: 2 * 1 = 2

스텍에 아직 남아 있는 원소들이 있다면, 처리합니다.

1. 2가 남아 있습니다.  
    - 높이: 2
    - 너비: 3 - 0 - 1 = 2 입니다.
    - 넓이: 2 * 2 = 4  

2를 없앱니다.

2. 1이 남았습니다.
    - 높이: 1
    - 너비: 3입니다. 이는 다른 원소들의 높이기 1이상이라는 것을 의미합니다.
    - 넓이: 1 * 3 = 3

4가 제일 크므로 4를 출력합니다.

- 3, 2, 1

1. 3을 넣습니다.
2. 2는 3보다 작습니다. 넓이를 구합니다.  
3은 이제 필요없으니 3을 제거합니다.
    - 높이: 2
    - 너비: 2(이는 지금까지 모든 원소의 높이가 2 이상인 것을 의미합니다. 3 > 2)
    - 넓이 2 * 2 = 4
3. 1은 2보다 작습니다. 넓이를 구합니다.  
2도 이제 필요 없으니 2도 제거합니다.
    - 높이: 1
    - 너비: 2(이는 지금까지 모든 원소의 높이가... 2 > 1)
    - 1 * 3 = 3

스택에 1이 남아 있으니 처리합니다.

4. 남아 있는 1 처리
    - 높이: 1
    - 너비: 3(3 > 2 > 1)
    - 넓이: 1 * 3 = 3

따라서 가장 넓은 4를 출력합니다.

- 3, 1, 2

1. 3을 넣습니다.
2. 1은 3보다 작습니다.  
3은 필요 없으니 제거합니다.
    - 높이: 1
    - 너비: 1(3 > 1)
    - 넓이: 1 * 1 = 1
    - 1을 넣습니다.

3. 2를 넣습니다. 

스택에 남아 있는 원소들을 처리합니다.

1. 2를 처리합니다.
    - 높이: 2
    - 너비: 3 - 1 - 1 = 1
    - 넓이: 2 * 1 = 2
2. 1을 처리합니다.
    - 높이: 1
    - 너비: 3(3 > 2 > 1)
    - 넓이: 1 * 3 = 3

따라서 가장 넓은 넓이인 3을 출력합니다.

#### 🖥️ source code

```c
#include<stdio.h>
#include<stdint.h>
#include<stdlib.h>

#define max(a, b)((a) > (b) ? (a) : (b))
typedef struct stack {
    int32_t* arr;
    int32_t top_idx;
} stack;

int32_t empty(const stack a) {
    return a.top_idx == -1 ? 1 : 0;
}

int32_t pop(stack *a) {
    a->top_idx -= 1;
    return 0;
}

int32_t peek(stack a) {
    return a.arr[a.top_idx];
}
int32_t push(stack *a, int32_t value) {
    a->arr[a->top_idx + 1] = value;
	a->top_idx += 1;
    return 0;
}

int64_t get_maximum_area(int32_t* arr, int32_t n) {
    stack a = {
        (int32_t*)malloc((n + 1) * sizeof(int32_t)),
        -1,
    };

	for (int i = 0; i <= n; i += 1) {
		a.arr[i] = -1;
	}

    int64_t max_area = 0;

    for (int32_t i = 0; i <= n; i += 1) {
		int32_t current_height = (i == n) ? 0 : arr[i]; 
        while (!empty(a) && current_height <= arr[peek(a)])  {
            int32_t height = arr[peek(a)];
            pop(&a);

            int32_t width = empty(a) ? i : i - peek(a) - 1;
            max_area = max(max_area, (int64_t)height * width);
        }
        push(&a, i);
    }

	return max_area;
}

int32_t main(void) {
    int32_t n;
    scanf("%d", &n);
    int32_t arr[n];

    for (int i = 0; i < n; i += 1) {
        scanf("%d", arr + i);
    }

    int64_t max_area = get_maximum_area(arr, n);
    printf("%ld\n", max_area);
    
    return 0;
}
```
