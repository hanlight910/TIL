---
id: "1780"
aliases: []
tags: []
---

# 💳 문제이해

흑백 영상을 압축하여 표현하는 데이터 구조를 쿼드 트리(Quad Tree)라는 
방법이 있습니다. 흰 점을 나타내는 0과 검은 점을 나타내는 1로만 이루어진 
영상(2차원 배열)에서 같은 숫자의 점들이 한 곳에 많이 몰려있으면,
쿼드 트리에서는 이를 압축하여 간단히 표현할 수 있습니다.

주어진 영상(2차원 배열)이 모두 0으로만 되어 있으면 압축 결과는 "0"이 되고,
모두 1로만 되어 있으면 압축 결과는 "1"이 된다. 만약 0과 1이 섞여 있으면,
전체를 한 번에 나타내지를 못하고, 왼쪽 위, 오른쪽 위, 왼쪽 아래, 오른쪽 아래,
이렇게 4개의 영상으로 나누어 압축하게 되며, 이 4개의 영역을 압축한 결과를
차례대로 괄호 안에 묶어서 표현한다.

# 🚥 문제접근

주어진 2차원 배열을 전체 탐색을 하여 0, 1, -1에 개수를 구하고 만약에 전체 요소의
개수가 전부 하나로 통일 되어 있지 않으면, **분할** 하여 다시 탐색해서 구합니다.
분할 횟수나, 해당 문제에서는 기본 3 * 3,
N에 값에 따라서 구하는 범위는 다르겠지만, 기본적으로 (N / 3) * (N / 3)의 규모의
자료에서 1, 0, -1 모든 원소의 값이 하나의 값으로 통일이 될 때까지
반복합니다. 참고로 N은 3의 배수.

## 1️⃣  문제풀이

1. 처음 N * N 사이즈의 이차원 배열을 전체 탐색합니다.
k모든 원소가 0, 1, -1중 하나로 통일 되어 있다면, 해당 숫자의 개수를 1 늘립니다.

2. 통일 되어 있지 않으면, (N / 3) * (N / 3)부분 메트릭스(행과열)를 현재 N * N
메트릭스에서 분할하여 각각 분할한 메트릭스에서 첫번째 순서를 반복합니다.

### source code

```c
#include<stdio.h>
#include<stdint.h>

void input(int32_t length, int32_t a[][length]) {
	char str[length];
    for (int32_t i = 0; i < length; i += 1) {
		scanf("%s", str);
        for (int32_t j = 0; j < length; j += 1) {
			a[i][j] = str[j] - 48;
        }
    }
    return;
}

void print_quad_tree(int32_t length, int32_t a[][length], int32_t x, int32_t y, int32_t N) {

	if (N == 1) {
		printf("%d", a[x][y]);
		return;
	}
	int32_t white = 0;
    for (int32_t i = x; i < N + x; i += 1) {
		for (int32_t j = y; j < N + y; j += 1) {
			if (a[i][j] == 0) {
				white += 1;
			}
		}
	}

	if (white == N * N) {
		printf("%d", 0);
	} else if (white == 0) {
		printf("%d", 1);
	} else {
		printf("(");
		print_quad_tree(length, a, x, y, N / 2);
		print_quad_tree(length, a, x, y + N / 2, N / 2);
		print_quad_tree(length, a, x + N / 2, y, N / 2);
		print_quad_tree(length, a, x + N / 2, y + N / 2, N / 2);
		printf(")");
	}

	return;
}

int32_t main(void) {
	int32_t length;
	scanf("%d", &length);

	int32_t a[length][length];

	input(length, a);
	print_quad_tree(length, a, 0, 0, length);
    return 0;
}
```

