---
id: "1780"
aliases: []
tags: []
---

# 💳 문제이해

흑백 영상을 압축하여 표현하는 데이터 구조를 쿼드 트리(Quad Tree)라는 
방법이 있습니다. 흰 점을 나타내는 0과 검은 점을 나타내는 1로만 이루어진 
영상(2차원 배열)에서 같은 숫자의 점들이 한 곳에 많이 몰려있으면,
쿼드 트리에서는 이를 압축하여 간단히 표현할 수 있습니다.

주어진 영상(2차원 배열)이 모두 0으로만 되어 있으면 압축 결과는 "0"이 되고,
모두 1로만 되어 있으면 압축 결과는 "1"이 된다. 만약 0과 1이 섞여 있으면,
전체를 한 번에 나타내지를 못하고, 왼쪽 위, 오른쪽 위, 왼쪽 아래, 오른쪽 아래,
이렇게 4개의 영상으로 나누어 압축하게 되며, 이 4개의 영역을 압축한 결과를
차례대로 괄호 안에 묶어서 표현한다.

# 🚥 문제접근

주어진 2차원 배열을 전체 탐색을 하여 0, 1, -1에 개수를 구하고 만약에 전체 요소의
개수가 전부 하나로 통일 되어 있지 않으면, **분할** 하여 다시 탐색해서 구합니다.
분할 횟수나, 해당 문제에서는 기본 3 * 3,
N에 값에 따라서 구하는 범위는 다르겠지만, 기본적으로 (N / 3) * (N / 3)의 규모의
자료에서 1, 0, -1 모든 원소의 값이 하나의 값으로 통일이 될 때까지
반복합니다. 참고로 N은 3의 거듭 제곱.

## 1️⃣  문제풀이

1. 처음 N * N 사이즈의 이차원 배열을 전체 탐색합니다.
k모든 원소가 0, 1, -1중 하나로 통일 되어 있다면, 해당 숫자의 개수를 1 늘립니다.

2. 통일 되어 있지 않으면, (N / 3) * (N / 3)부분 메트릭스(행과열)를 현재 N * N
메트릭스에서 분할하여 각각 분할한 메트릭스에서 첫번째 순서를 반복합니다.

### source code

```c
#include<stdio.h>
#include<stdint.h>

void input(int32_t N, int32_t a[][N]) {
	for (int32_t i = 0; i < N; i += 1) {
		for (int32_t j = 0; j < N; j += 1) {
			scanf("%d", &a[i][j]);
		}
	}
}

struct Set {
	int32_t zero;
	int32_t one;
	int32_t negative_one;
};

void get_number_set(struct Set* b, const int32_t length,  int32_t n, int32_t a[][length], int32_t x, int32_t y) {
	struct Set temp = {
		.zero = 0,
		.one = 0,
		.negative_one = 0, 
	};

	for (int32_t i = y; i < y + n; i += 1) {
		for (int32_t j = x; j < x + n; j += 1) {
			if (a[i][j] == 1) { 
				temp.one += 1;
			} else if (a[i][j] == 0) {
				temp.zero += 1;
			} else {
				temp.negative_one += 1;
			}
		}


	}

	if (temp.zero == n * n) {
		b->zero += 1;
	} else if (temp.one == n * n) {
		(*b).one += 1;
	} else if (temp.negative_one == n * n) {
		(*b).negative_one += 1;
	} else {
		get_number_set(b, length, n / 3, a, x, y);
		get_number_set(b, length, n / 3, a, x + n / 3, y);
		get_number_set(b, length, n / 3, a, x + (n / 3 * 2), y);

		get_number_set(b, length, n / 3, a, x, y + n / 3);
		get_number_set(b, length, n / 3, a, x + n / 3, y + n / 3);
		get_number_set(b, length, n / 3, a, x + (n / 3 * 2), y + n / 3);

		get_number_set(b, length, n / 3, a, x, y + (n / 3 * 2));
		get_number_set(b, length, n / 3, a, x + n / 3, y + (n / 3 * 2));
		get_number_set(b, length, n / 3, a, x + (n / 3 * 2), y + (n / 3 * 2));
	}
	return;
}

int32_t main(void) {
	int32_t N;
	scanf("%d", &N);
	int32_t a[N][N];
	input(N, a);
	struct Set b = {
		.zero = 0,
		.one = 0,
		.negative_one = 0,	
	};

	get_number_set(&b, N, N, a, 0, 0);
	printf("%d\n", b.negative_one);
	printf("%d\n", b.zero);
	printf("%d\n", b.one);

	return 0;
}
```

