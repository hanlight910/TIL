---
id: "11286"
aliases: []
tags: []
---

# 💳 문제이해

N개의 정수가 주어졌을 때, 각 정수의 따라선 다른 연산을 합니다.
해당 정수가 0이 아니면, 힙에 추가합니다. 반대로 0이면, 힙에 저장되어 있는
정수 들 중 가장 작은 절대값을 출력합니다. 가장 작은 절대값이 여러 개 존재한다면,
가장 작은 정수를 출력합니다.

#  🚥 문제접근

주어진 수들을 힙에 저장하는 이유는 최소값을 여러번 찾을 수 있는 점도 있지만,
계속해서 추가되는 수를 효율적으로 관리 할 수 있습니다.

## 힙(Heap) 

1. 정수 추가
2. 맨 아래 노드부터 정렬
3. 가장 작은 값 내보내기
4. 루트 노드에서부터 정렬

## 🖥️ source code

```c
#include<stdio.h>
#include<stdint.h>
#include<stdlib.h>

typedef struct {
    int32_t* arr;
    int32_t size;
} heap;

void insert(heap* a, int32_t value) {
    a->arr[a->size] = value;
    a->size += 1;
    return;
}

void swap(int32_t* a, int32_t* b) {
    int32_t temp = *a;
    *a = *b;
    *b = temp;
    return;
}

void heapify_down(heap* a) {
    if (a->size <= 1) {
        return;
    }

    int32_t parent_node = 0;
    int32_t left_node = 0;
    int32_t right_node = 0;

    while (parent_node < a->size - 1) {
        left_node = (parent_node * 2) + 1;
        right_node = (parent_node * 2) + 2;
        int32_t right_num = 0;
		int32_t left_num = 0;
		if (left_node < a->size) {
			left_num = a->arr[left_node];
		}

		if (right_node < a->size) {
			right_num = a->arr[right_node];
		}
        int32_t min_node = parent_node;
        int32_t parent_num = a->arr[parent_node];
		int32_t min_num = a->arr[min_node];

        if (a->arr[parent_node] < 0) {
            parent_num = parent_num * -1;
			min_num = parent_num;
        }
        if (
            left_node < a->size &&
            a->arr[left_node] < 0
            ) {
            left_num = a->arr[left_node] * -1;
        }

        if (right_node < a->size && a->arr[right_node] < 0) {
            right_num = a->arr[right_node] * -1;
        }

        if (left_node < a->size && min_num > left_num) {
			min_num = left_num;
            min_node = left_node;
        } else if (left_node < a->size && min_num == left_num) {
            if (a->arr[min_node] > a->arr[left_node]) {
                min_node = left_node;
            }
        }

        if (right_node < a->size && min_num > right_num) {
            min_node = right_node;
			min_num = right_num;
        } else if (right_node < a->size && a->arr[min_node] == right_num) {
            if (a->arr[min_node] > a->arr[right_node]) {
                min_node = right_node;
            }
        }
		//
		// printf("ll: %d %d %d\n", a->arr[left_node], a->arr[right_node], a->arr[parent_node]);
		// printf("ll: %d\n", a->arr[min_node]);
        if (min_node != parent_node) {
            swap(&a->arr[min_node], &a->arr[parent_node]);
			parent_node = min_node;
        } else {
            break;
        }
    }
    return;
}

void heapify_up(heap* a) {
    if (a->size <= 1) {
        return;
    }
    int32_t child_node = a->size - 1;

    while (child_node > 0) {
        int32_t parent_node = (child_node - 1) / 2;
        int32_t child_num = a->arr[child_node];
        int32_t parent_num = a->arr[parent_node];

        if (a->arr[child_node] < 0) {
            child_num = a->arr[child_node] * -1;
        } 
        if (a->arr[parent_node] < 0) {
            parent_num = a->arr[parent_node] * -1;
        }

        if (child_num < parent_num) {
            swap(&a->arr[child_node], &a->arr[parent_node]);
			child_node = parent_node;
        } else if (child_num == parent_num) {
            if (a->arr[child_node] < a->arr[parent_node]) {
                swap(&a->arr[child_node], &a->arr[parent_node]);
				child_node = parent_node;
            } else {
                break;
            }
        } else {
            break;
        }
    }

    return;
}

int32_t extract_min_num(heap* a) {
	if (a->size == 0) {
		return 0;
	}

    int32_t min_num = a->arr[0];
    a->arr[0] = a->arr[a->size - 1];
    a->size -= 1;
    heapify_down(a);

    return min_num;
}

int32_t main(void) {
    int32_t n;
    scanf("%d", &n);

    int32_t arr[n];
    for (int32_t i = 0; i < n; i += 1) {
        scanf("%d", &arr[i]);
    }

    heap a = {
        (int32_t*)calloc(n, sizeof(int32_t)),
        0,
    };

    for (int i = 0; i < n; i += 1) {
        if (arr[i] != 0) {
            insert(&a, arr[i]);
            heapify_up(&a);
        } else {
            printf("%d\n", extract_min_num(&a));
            heapify_down(&a);
        }
    }
    
    return 0;
}
```
