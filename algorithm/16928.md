---
id: "16928"
aliases:
  - 뱀과 사다리 게임
tags:
  - bfs
  - 0_weight
---

# 💳 문제이해

1 부터 100까지 칸으로 이루어진 사다리 보드게임이 주어진다. 보드게임에는
'뱀'과 '사다리'가 있는데, 뱀이 위치한 곳에 도달하면 뱀의 위치보다 더 작은
작은 칸으로 이동하게 된다. 반대로 사다리 칸에 도착하면, 사다리보다
더 큰 칸으로 이동하게 된다. 주사위는 정육면체로 1부터 6까지 표현할 수 있다.
최소한의 주사위를 굴려 100에 도달하시오.

# 🚥 문제접근

그래프 순회 문제입니다. 각 정점(노드)은 6개의 간선(주사위)를 가집니다.
각 정점을 방문할 경우, '뱀'과 '사다리'의 추가적인 로직을 짜면 될 것 
같습니다.

`BFS`를 사용해서, 최단 경로를 구합니다.

## 🌏 분석

### 🌂 BFS

그래프/트리에서 너비를 우선적으로 탐색하는 탐색 알고리즘 중 하나로,
최단 거리를 구하는데에 적절합니다. 가중치만 작거나, 같으면.

`queue`의 특성인 먼저 들어온 값을 우선적으로 처리하는 기능을 활용하여,
탐색한 노드의 깊이를 탐색합니다.

주어진 정점들의 간선은 평균 12개 입니다. 32 의 연결된 간선은 26~31와 
33\~38입니다. 주사위가 최대 6을 표현하기 때문입니다.

> ...소스 코드 짜는 중...

간과했습니다. 사다리, 뱀을 통해 다른 노드를 이동할 때 필요한 주사위
횟수는 0입니다. 이는 가중치가 0인 것을 의미합니다.

`BFS` 최단 경로는 모든 정점의 가중치가 동이할 경우에만 최단 경로를
구할 수 있습니다.

따라서 100에 도달하였을 때, 최소 값을 구하는 로직을 추가했습니다.

추가적으로, 가중치가 0인 경우에도 최단 경로를 구할 수 있는 방법이 있다고
합니다. [https://www.geeksforgeeks.org/0-1-bfs-shortest-path-binary-graph/](https://www.geeksforgeeks.org/0-1-bfs-shortest-path-binary-graph/)

##### 🖥️ source code

```c
#include<stdio.h>
#include<stdint.h>
#include<stdlib.h>

#define pr(val, snake) (printf("val: %d; snLa: %d\n", val, snake))

#define enqueue(q, data) do { \
	queue* new_q = (queue*)malloc(sizeof(queue)); \
	new_q->val = data; \
	new_q->next = NULL; \
	if (*q == NULL) { \
		new_q->head = new_q; \
		*q = new_q; \
	} else { \
		new_q->head = (*q)->head; \
		(*q)->next = new_q; \
		*q = new_q; \
	} \
} while (0)

typedef struct {
	int32_t* visited;
	int32_t* dist;
	int32_t max_ln;
	int32_t min_ln;
} Graph;

typedef struct hash {
	int32_t key;
	int32_t value;
	struct hash* next;
} hash;

typedef struct Node {
	int32_t val;
	struct Node* next;
	struct Node* head;
} queue;

int32_t get_key_val(hash *q, int32_t key) {
	while (q != NULL) {
		if ((*q).key == key) {
			return (*q).value;
		} else {
			q = (*q).next;
		}
	}
	return 0;
}

hash* insert_key_val(hash* h, int32_t key, int32_t val) {
	hash* new_h = (hash*)malloc(sizeof(hash));
	new_h->key = key;
	new_h->value = val;
	new_h->next = NULL;

	if (h == NULL) {
		h = new_h;
	} else {
		hash* tmp = h;
		while (tmp->next != NULL) {
			tmp = tmp->next;
		}
		tmp->next = new_h;
	}

	return h;
}

int32_t dequeue(queue** q) {
	int32_t val = 0;
	if (*q != NULL) {
		val = (**q).head->val;
		queue* tmp = (*q)->head;
		if ((**q).head->next == NULL) {
			*q = NULL;
		} else {
			(**q).head = (**q).head->next;
		}
		free(tmp);
	}
	return val;
}

_Bool is_valid(Graph* g, int32_t coord) {
	if (g->max_ln > coord && coord >= g->min_ln) {
		if (!g->visited[coord]) {
			return 1;
		}
	}
	return 0;
}

typedef enum Board { NONE, SNAKE, LADDER } Board;

int32_t is_lad_or_snake(hash* snake, hash* lad, int32_t key) {
	Board cur;

	int32_t is_snake = get_key_val(snake, key);
	int32_t is_lad = get_key_val(lad, key);
	if (is_snake > 0) {
		cur = SNAKE;
	} else if (is_lad > 0) {
		cur = LADDER;
	} else {
		cur = NONE;
	}
	return cur;
}

hash* input_hash(hash* h, int32_t ln) {
	for (int32_t i = 0; i < ln; i += 1) {
		int32_t key, value;
		scanf("%d %d", &key, &value);
		h = insert_key_val(h, key, value);
	} 
	return h;
}

int32_t BFS(Graph g, hash* lad, hash* snake) {
	queue* q = NULL;

	int32_t directions[6] = { 1, 2, 3, 4, 5, 6 };

	enqueue(&q, 1);

	g.visited[1] = 1;

	int32_t min_path = 100;

	while (q != NULL) {
		int32_t cur_v = dequeue(&q);

		// printf("dice: %d\n", cur_v);
		for (int32_t i = 0; i < 6; i += 1) {
			int32_t cur_d = cur_v + directions[i];

			if (is_valid(&g, cur_d)) {
				// enqueue(&q, cur_d);
				g.visited[cur_d] = 1;
				g.dist[cur_d] = g.dist[cur_v] + 1;

				int32_t lad_or_snake = is_lad_or_snake(snake, lad, cur_d);
				// pr(cur_d, g.dist[cur_v]);

				if (lad_or_snake > 0) {
					cur_d = lad_or_snake == 2 ? get_key_val(lad, cur_d) :
						get_key_val(snake, cur_d);
					// printf("lad or snake: %d\n", cur_d);
					if (is_valid(&g, cur_d)) {
						// printf("inserted: %d\n", cur_d);
						enqueue(&q, cur_d);
						g.dist[cur_d] = g.dist[cur_v] + 1;
						g.visited[cur_d] = 1;
					}
					if (cur_d == 100) {
						min_path = g.dist[cur_d] < min_path ? g.dist[cur_d]	: min_path;
					}
				} else {
					enqueue(&q, cur_d);
				} 

				if (cur_d == 100) {
					// printf("cur_d: %d\n", g.dist[cur_d]);
					min_path = g.dist[cur_d] < min_path ? g.dist[cur_d]	: min_path;
				}
			}
		}
	}

	return min_path;
}

int32_t main(void) {
	int32_t S, L;
	scanf("%d %d", &L, &S);

	Graph g = {
		.visited = (int32_t*)calloc(101, sizeof(int32_t)),
		.dist = (int32_t*)calloc(101, sizeof(int32_t)),
		.max_ln = 101,
		.min_ln = 1,
	};
	hash* lad = NULL;
	hash* snake = NULL;
	lad = input_hash(lad, L);
	snake = input_hash(snake, S);

	int32_t path = BFS(g, lad, snake);
	printf("%d\n", path);

	return 0;
}
```
