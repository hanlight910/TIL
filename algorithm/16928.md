---
id: "16928"
aliases:
  - ë±€ê³¼ ì‚¬ë‹¤ë¦¬ ê²Œì„
tags:
  - bfs
  - 0_weight
---

# ğŸ’³ ë¬¸ì œì´í•´

1 ë¶€í„° 100ê¹Œì§€ ì¹¸ìœ¼ë¡œ ì´ë£¨ì–´ì§„ ì‚¬ë‹¤ë¦¬ ë³´ë“œê²Œì„ì´ ì£¼ì–´ì§„ë‹¤. ë³´ë“œê²Œì„ì—ëŠ”
'ë±€'ê³¼ 'ì‚¬ë‹¤ë¦¬'ê°€ ìˆëŠ”ë°, ë±€ì´ ìœ„ì¹˜í•œ ê³³ì— ë„ë‹¬í•˜ë©´ ë±€ì˜ ìœ„ì¹˜ë³´ë‹¤ ë” ì‘ì€
ì‘ì€ ì¹¸ìœ¼ë¡œ ì´ë™í•˜ê²Œ ëœë‹¤. ë°˜ëŒ€ë¡œ ì‚¬ë‹¤ë¦¬ ì¹¸ì— ë„ì°©í•˜ë©´, ì‚¬ë‹¤ë¦¬ë³´ë‹¤
ë” í° ì¹¸ìœ¼ë¡œ ì´ë™í•˜ê²Œ ëœë‹¤. ì£¼ì‚¬ìœ„ëŠ” ì •ìœ¡ë©´ì²´ë¡œ 1ë¶€í„° 6ê¹Œì§€ í‘œí˜„í•  ìˆ˜ ìˆë‹¤.
ìµœì†Œí•œì˜ ì£¼ì‚¬ìœ„ë¥¼ êµ´ë ¤ 100ì— ë„ë‹¬í•˜ì‹œì˜¤.

# ğŸš¥ ë¬¸ì œì ‘ê·¼

ê·¸ë˜í”„ ìˆœíšŒ ë¬¸ì œì…ë‹ˆë‹¤. ê° ì •ì (ë…¸ë“œ)ì€ 6ê°œì˜ ê°„ì„ (ì£¼ì‚¬ìœ„)ë¥¼ ê°€ì§‘ë‹ˆë‹¤.
ê° ì •ì ì„ ë°©ë¬¸í•  ê²½ìš°, 'ë±€'ê³¼ 'ì‚¬ë‹¤ë¦¬'ì˜ ì¶”ê°€ì ì¸ ë¡œì§ì„ ì§œë©´ ë  ê²ƒ 
ê°™ìŠµë‹ˆë‹¤.

`BFS`ë¥¼ ì‚¬ìš©í•´ì„œ, ìµœë‹¨ ê²½ë¡œë¥¼ êµ¬í•©ë‹ˆë‹¤.

## ğŸŒ ë¶„ì„

### ğŸŒ‚ BFS

ê·¸ë˜í”„/íŠ¸ë¦¬ì—ì„œ ë„ˆë¹„ë¥¼ ìš°ì„ ì ìœ¼ë¡œ íƒìƒ‰í•˜ëŠ” íƒìƒ‰ ì•Œê³ ë¦¬ì¦˜ ì¤‘ í•˜ë‚˜ë¡œ,
ìµœë‹¨ ê±°ë¦¬ë¥¼ êµ¬í•˜ëŠ”ë°ì— ì ì ˆí•©ë‹ˆë‹¤. ê°€ì¤‘ì¹˜ë§Œ ì‘ê±°ë‚˜, ê°™ìœ¼ë©´.

`queue`ì˜ íŠ¹ì„±ì¸ ë¨¼ì € ë“¤ì–´ì˜¨ ê°’ì„ ìš°ì„ ì ìœ¼ë¡œ ì²˜ë¦¬í•˜ëŠ” ê¸°ëŠ¥ì„ í™œìš©í•˜ì—¬,
íƒìƒ‰í•œ ë…¸ë“œì˜ ê¹Šì´ë¥¼ íƒìƒ‰í•©ë‹ˆë‹¤.

ì£¼ì–´ì§„ ì •ì ë“¤ì˜ ê°„ì„ ì€ í‰ê·  12ê°œ ì…ë‹ˆë‹¤. 32 ì˜ ì—°ê²°ëœ ê°„ì„ ì€ 26~31ì™€ 
33\~38ì…ë‹ˆë‹¤. ì£¼ì‚¬ìœ„ê°€ ìµœëŒ€ 6ì„ í‘œí˜„í•˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.

> ...ì†ŒìŠ¤ ì½”ë“œ ì§œëŠ” ì¤‘...

ê°„ê³¼í–ˆìŠµë‹ˆë‹¤. ì‚¬ë‹¤ë¦¬, ë±€ì„ í†µí•´ ë‹¤ë¥¸ ë…¸ë“œë¥¼ ì´ë™í•  ë•Œ í•„ìš”í•œ ì£¼ì‚¬ìœ„
íšŸìˆ˜ëŠ” 0ì…ë‹ˆë‹¤. ì´ëŠ” ê°€ì¤‘ì¹˜ê°€ 0ì¸ ê²ƒì„ ì˜ë¯¸í•©ë‹ˆë‹¤.

`BFS` ìµœë‹¨ ê²½ë¡œëŠ” ëª¨ë“  ì •ì ì˜ ê°€ì¤‘ì¹˜ê°€ ë™ì´í•  ê²½ìš°ì—ë§Œ ìµœë‹¨ ê²½ë¡œë¥¼
êµ¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ë”°ë¼ì„œ 100ì— ë„ë‹¬í•˜ì˜€ì„ ë•Œ, ìµœì†Œ ê°’ì„ êµ¬í•˜ëŠ” ë¡œì§ì„ ì¶”ê°€í–ˆìŠµë‹ˆë‹¤.

ì¶”ê°€ì ìœ¼ë¡œ, ê°€ì¤‘ì¹˜ê°€ 0ì¸ ê²½ìš°ì—ë„ ìµœë‹¨ ê²½ë¡œë¥¼ êµ¬í•  ìˆ˜ ìˆëŠ” ë°©ë²•ì´ ìˆë‹¤ê³ 
í•©ë‹ˆë‹¤. [https://www.geeksforgeeks.org/0-1-bfs-shortest-path-binary-graph/](https://www.geeksforgeeks.org/0-1-bfs-shortest-path-binary-graph/)

##### ğŸ–¥ï¸ source code

```c
#include<stdio.h>
#include<stdint.h>
#include<stdlib.h>

#define pr(val, snake) (printf("val: %d; snLa: %d\n", val, snake))

#define enqueue(q, data) do { \
	queue* new_q = (queue*)malloc(sizeof(queue)); \
	new_q->val = data; \
	new_q->next = NULL; \
	if (*q == NULL) { \
		new_q->head = new_q; \
		*q = new_q; \
	} else { \
		new_q->head = (*q)->head; \
		(*q)->next = new_q; \
		*q = new_q; \
	} \
} while (0)

typedef struct {
	int32_t* visited;
	int32_t* dist;
	int32_t max_ln;
	int32_t min_ln;
} Graph;

typedef struct hash {
	int32_t key;
	int32_t value;
	struct hash* next;
} hash;

typedef struct Node {
	int32_t val;
	struct Node* next;
	struct Node* head;
} queue;

int32_t get_key_val(hash *q, int32_t key) {
	while (q != NULL) {
		if ((*q).key == key) {
			return (*q).value;
		} else {
			q = (*q).next;
		}
	}
	return 0;
}

hash* insert_key_val(hash* h, int32_t key, int32_t val) {
	hash* new_h = (hash*)malloc(sizeof(hash));
	new_h->key = key;
	new_h->value = val;
	new_h->next = NULL;

	if (h == NULL) {
		h = new_h;
	} else {
		hash* tmp = h;
		while (tmp->next != NULL) {
			tmp = tmp->next;
		}
		tmp->next = new_h;
	}

	return h;
}

int32_t dequeue(queue** q) {
	int32_t val = 0;
	if (*q != NULL) {
		val = (**q).head->val;
		queue* tmp = (*q)->head;
		if ((**q).head->next == NULL) {
			*q = NULL;
		} else {
			(**q).head = (**q).head->next;
		}
		free(tmp);
	}
	return val;
}

_Bool is_valid(Graph* g, int32_t coord) {
	if (g->max_ln > coord && coord >= g->min_ln) {
		if (!g->visited[coord]) {
			return 1;
		}
	}
	return 0;
}

typedef enum Board { NONE, SNAKE, LADDER } Board;

int32_t is_lad_or_snake(hash* snake, hash* lad, int32_t key) {
	Board cur;

	int32_t is_snake = get_key_val(snake, key);
	int32_t is_lad = get_key_val(lad, key);
	if (is_snake > 0) {
		cur = SNAKE;
	} else if (is_lad > 0) {
		cur = LADDER;
	} else {
		cur = NONE;
	}
	return cur;
}

hash* input_hash(hash* h, int32_t ln) {
	for (int32_t i = 0; i < ln; i += 1) {
		int32_t key, value;
		scanf("%d %d", &key, &value);
		h = insert_key_val(h, key, value);
	} 
	return h;
}

int32_t BFS(Graph g, hash* lad, hash* snake) {
	queue* q = NULL;

	int32_t directions[6] = { 1, 2, 3, 4, 5, 6 };

	enqueue(&q, 1);

	g.visited[1] = 1;

	int32_t min_path = 100;

	while (q != NULL) {
		int32_t cur_v = dequeue(&q);

		// printf("dice: %d\n", cur_v);
		for (int32_t i = 0; i < 6; i += 1) {
			int32_t cur_d = cur_v + directions[i];

			if (is_valid(&g, cur_d)) {
				// enqueue(&q, cur_d);
				g.visited[cur_d] = 1;
				g.dist[cur_d] = g.dist[cur_v] + 1;

				int32_t lad_or_snake = is_lad_or_snake(snake, lad, cur_d);
				// pr(cur_d, g.dist[cur_v]);

				if (lad_or_snake > 0) {
					cur_d = lad_or_snake == 2 ? get_key_val(lad, cur_d) :
						get_key_val(snake, cur_d);
					// printf("lad or snake: %d\n", cur_d);
					if (is_valid(&g, cur_d)) {
						// printf("inserted: %d\n", cur_d);
						enqueue(&q, cur_d);
						g.dist[cur_d] = g.dist[cur_v] + 1;
						g.visited[cur_d] = 1;
					}
					if (cur_d == 100) {
						min_path = g.dist[cur_d] < min_path ? g.dist[cur_d]	: min_path;
					}
				} else {
					enqueue(&q, cur_d);
				} 

				if (cur_d == 100) {
					// printf("cur_d: %d\n", g.dist[cur_d]);
					min_path = g.dist[cur_d] < min_path ? g.dist[cur_d]	: min_path;
				}
			}
		}
	}

	return min_path;
}

int32_t main(void) {
	int32_t S, L;
	scanf("%d %d", &L, &S);

	Graph g = {
		.visited = (int32_t*)calloc(101, sizeof(int32_t)),
		.dist = (int32_t*)calloc(101, sizeof(int32_t)),
		.max_ln = 101,
		.min_ln = 1,
	};
	hash* lad = NULL;
	hash* snake = NULL;
	lad = input_hash(lad, L);
	snake = input_hash(snake, S);

	int32_t path = BFS(g, lad, snake);
	printf("%d\n", path);

	return 0;
}
```
