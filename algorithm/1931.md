---
id: "1931"
aliases: []
tags: []
---

# Reflection

## 💳 문제이해

회의 수 N이 주어졌을 때, 회의 마다 시작하는 시간과 끝나는 시간이 있습니다.
다음 회의 시간의 시작하는 시간이 전 회의 시간의 끝나는 시간 이상일 경우, 
해당 조건을 만족하는 최대 회의 개수를 구하세요.

## 🚥 문제접근

> 시작 시간, 끝나는 시간의 차이가 적을수록 더 많은 회의를 진행 할 수 있습니다.

시작 시간을 기준으로 해당 희의를 오름차순으로 정렬한 다음에, 각 희의당 모든
회의를 순회하여 다음 회의 시간의 대한 누계 합계를 구합니다.

### 1️⃣  문제풀이

```
정렬 전
1 4
3 5
0 6
5 7
3 8
5 9
6 10
8 11
8 12
2 13
12 14
```

```
정렬 후
0 6
1 4
2 13
3 5
3 8
5 7
5 9
6 10
8 11
8 12
12 14
```
order|expression|max meeting
:---:|:---:|:---:
1 | 6 | 1
2 | 6 > 1 | 1
3 | 4 > 2 | 1
4 | 4 > 3 | 1
5 | 5 = 5 | 2
6 | 7 > 5 | 2
7 | 7 > 6 | 2
8 | 7 < 8 | 3
9 | 11 > 8 | 3
10 | 11 < 12 | 4

해당 끝나는 시간이 전에 끝나는 시간보다 작거나, 회의가 새로 갱신 될 경우,
최소 끝나는 시간을 갱신합니다.

```py
import sys;

inputed: list[str] = list(sys.stdin.readline().rstrip().split());
N: int = int(inputed[0]);

meetings: list[dict] = list();

for _ in range(0, N):
    inputed = list(sys.stdin.readline().rstrip().split());
    meetings.append({   
        "start": int(inputed[0]),
        "end": int(inputed[1]),
            }

def myFunc(e):
    return e["start"];

meetings.sort(key=myFunc);

min_end_time: int = meetings[0]["end"];
max_meeting: int = 1;

for meeting in meetings[1:]:
    if min_end_time >= meeting["start"]:
        min_end_time = meeting["end"];
        max_meeting += 1;

    elif min_end_time > meeting["end"]:
        min_end_time = meeting["end"];

print(max_meeting);
```

하지만 70%까지 갔는데 실패했습니다.
 
그 이유는 

```
1 2
1 0
```

위에 케이스 같은 경우 시작 시간이 같습니다.

이는 정렬을 해주지 않기 때문에, 만약에 시작 시간이 같으면, 끝나는 시간도 정렬
해주면 됩니다.

```py
import sys;

inputed: list[str] = list(sys.stdin.readline().rstrip().split());
N: int = int(inputed[0]);

meetings: list[dict] = list();

for _ in range(0, N):
    inputed = list(sys.stdin.readline().rstrip().split());
    meetings.append({   
        "start": int(inputed[0]),
        "end": int(inputed[1]),
            }

meetings.sort(key=lambda e: (e["start"], e["end"]));

min_end_time: int = meetings[0]["end"];
max_meeting: int = 1;

for meeting in meetings[1:]:
    if min_end_time >= meeting["start"]:
        min_end_time = meeting["end"];
        max_meeting += 1;

    elif min_end_time > meeting["end"]:
        min_end_time = meeting["end"];

print(max_meeting);
```

#### 2️⃣  문제풀이

다만 1번 문제풀이 같은 경우 시작 시간을 정렬을 해도 끝나는 시간이 랜덤이라,
최소 끝나는 시간을 구해야 더 많은 회의 시간을 구할 수 있습니다.

이는 애초에 끝나는 시간을 정렬하면 적어도 시작 시간은 끝나는 시간에 같거난 작기 때문에,
컨트롤 할 수 있습니다.


#### source code

```py
import sys;

inputed: list[str] = list(sys.stdin.readline().rstrip().split());
N: int = int(inputed[0]);

meetings: list[dict] = list();

for _ in range(0, N):
    inputed = list(sys.stdin.readline().rstrip().split());
    meetings.append({   
        "start": int(inputed[0]),
        "end": int(inputed[1]),
            });

meetings.sort(key=lambda e: (e["end"], e["start"]));

min_end_time: int = meetings[0]["end"];
max_meeting: int = 1;

for meeting in meetings[1:]:
    if min_end_time >= meeting["start"]:
        min_end_time = meeting["end"];
        max_meeting += 1;

print(max_meeting);
```
