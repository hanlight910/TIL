---
id: "1920"
aliases: []
tags: []
---

# ðŸ’³ ë¬¸ì œì´í•´

Nê°œ ì •ìˆ˜ë¡œ ì´ë£¨ì–´ì§„ ìˆ˜ì—´ì´ ì£¼ì–´ì¡Œì„ ë•Œ, Mê°œì˜ ìˆ˜ë“¤ì´ í•´ë‹¹ ìˆ˜ì—´ì— í¬í•¨ë˜ì–´ ìžˆìœ¼ë©´
1ì„ ì¶œë ¥, ì•„ë‹ˆë©´ 0ì„ ì¶œë ¥í•´ì£¼ì„¸ìš”.

ðŸš¥ ë¬¸ì œì ‘ê·¼

ë¹ ë¥´ê²Œ í•´ë‹¹ ì›ì†Œê°€ ë°°ì—´/ìˆ˜ì—´ì— ìžˆëŠ” ê²ƒì„ ì°¾ê¸° ìœ„í•´ì„œëŠ” ëª¨ë“  ìˆ˜ì—´ì„ íƒìƒ‰í•˜ëŠ”
ê²Œ ì •ì„ì´ì§€ë§Œ ë” ë¹ ë¥´ê²Œ íƒìƒ‰í•˜ëŠ” ë°©ë²• ì¤‘ í•˜ë‚˜ê°€ `ì´ì§„ íƒìƒ‰`ìž…ë‹ˆë‹¤.

ì´ë¶„ íƒìƒ‰ì€ ë¨¼ì € ìˆ˜ì—´ì´ ì •ë ¬ì´ ë˜ì–´ì•¼ í•˜ëŠ” ì¡°ê±´ì„ ê°€ì§€ê³  ìžˆì§€ë§Œ

í•˜ì§€ë§Œ ë¹ ë¥¸ ì‹œê°„ ë³µìž¡ë„ ì¤‘ í•˜ë‚˜ì¸ O(log$_2$N)ì„ ê¸°ë¡í•©ë‹ˆë‹¤.

ì´ë¶„ íƒìƒ‰ì€ í•´ë‹¹ ì¤‘ê°„ì— ìžˆëŠ” ê°’ì„ ê¸°ì¤€ìœ¼ë¡œ ì°¾ëŠ” ê°’ì´ ìž‘ìœ¼ë©´, ìˆ˜ì—´ì´ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ
ì •ë ¬ ë˜ì–´ ìžˆì„ ê²½ìš°, ì™¼ìª½ ì ˆë°˜ ìˆ˜ì—´ íƒìƒ‰í•©ë‹ˆë‹¤. ë˜ ì™¼ìª½ ì ˆë°˜ ìˆ˜ì—´ì—ì„œ ì¤‘ê°„ ê°’ì„
ê¸°ì¤€ìœ¼ë¡œ ì°¾ëŠ” ê°’ì´ í¬ë©´ ì´ë²ˆì—” ì¢Œì¸¡ ì ˆë°˜ ìˆ˜ì—´ì— ìš°ì¸¨ ì ˆë°˜ì„ íƒìƒ‰í•©ë‹ˆë‹¤. ìœ„ ê³¼ì •ì„
ì°¾ê³  ìžˆëŠ” ì›ì†Œë¥¼ ì°¾ì„ ë•Œê¹Œì§€ ë°˜ë³µí•©ë‹ˆë‹¤.

ì´ê²ƒì€ ì‚¬ëžŒì´ 1ë¶€í„° 100ê¹Œì§€ ìˆ˜ í•˜ë‚˜ë¥¼ ë§žì³ë³´ë¼ê³  í•  ë•Œ ìœ ìš©í•  ê±° ê°™ìŠµë‹ˆë‹¤.

ì°¾ëŠ” ìˆ«ëŠ” 7

- ì§ˆë¬¸ìž: "50ë³´ë‹¤ í°ê°€ìš”?"
- ë‹µë³€ìž: "ì•„ë‹ˆìš”"
- ì§ˆë¬¸ìž: "26ë³´ë‹¤ ìž‘ì€ê°€ìš”?"
- ë‹µë³€ìž: "ì˜ˆ"
- ì§ˆë¬¸ìž: "12ë³´ë‹¤ í°ê°€ìš”?"
- ë‹µë³€ìž: "ì•„ë‹ˆìš”"
- ì§ˆë¬¸ìž: "6ë³´ë‹¤ í°ê°€ìš”?"
- ë‹µë³€ìž: "ë„¤"
- ì§ˆë¬¸ìž: "10ë³´ë‹¤ ìž‘ì€ê°€ìš”?"
- ë‹µë³€ìž: "ë„¤"
- ì§ˆë¬¸ìž: "8ë³´ë‹¤ ìž‘ì€ê°€ìš”?"
- ë‹µë³€ìž: "ë„¤"
- ì§ˆë¬¸ìž: "ì°¾ëŠ” ìˆ˜ëŠ” 7ì¸ê°€ìš”?"
- ë‹µë³€ìž: "ì •ë‹µìž…ë‹ˆë‹¤."

ë„¤, ìµœì†Œ 6ë²ˆ ë¬¼ì–´ë³¸ ê²ƒìœ¼ë¡œ ì°¾ëŠ” ìˆ«ìžë¥¼ ì°¾ì„ ìˆ˜ ìžˆì—ˆìŠµë‹ˆë‹¤. ì´ëŠ” $log_2N$ì´ë¼ëŠ”
ì‚¬ì‹¤ì„ ì¦ëª…í•©ë‹ˆë‹¤.

## 1ï¸âƒ£  ë¬¸ì œí’€ì´

1. í•©ë³‘ì •ë ¬(merge ì •ë ¬ë¡œ ì •ë ¬í•˜ê¸°)

```mermaid
flowchart TD
if_split{"element is greater than 1"}
if_split_t["split left and right"]
split_left["0 to mid"]
split_right["mid + 1 to length"]
then["continue splitting"]

if_split_f["merge the left and right"]

if_split -- true --> if_split_t 
if_split_t --> split_left & split_right --> then --> if_split_f
then --> if_split
```

2. ì´ë¶„íƒìƒ‰

```mermaid
flowchart TD

if_founded{"if ì¤‘ê°„ ìˆ˜ê°€ ì°¾ë˜ ìˆ«ìžë¼ë©´"}
if_founded_t["ì¤‘ê°„ ìˆ˜ê°€ ì°¾ë˜ ìˆ«ìžìž…ë‹ˆë‹¤."]
if_founded_f{"ì¤‘ê°„ ìˆ˜ ë³´ë‹¤ í½ë‹ˆê¹Œ?"}
if_left["ì¤‘ê°„ ìˆ˜ ë¯¸ë§Œì¸ êµ¬ê°„ì— ì¤‘ê°„ ìˆ˜ë¥¼ ìƒˆë¡œìš´ ì¤‘ê°„ ìˆ˜ë¡œ ì •í•©ë‹ˆë‹¤."]
if_right["ì¤‘ê°„ ìˆ˜ ì´ˆê³¼ì¸ êµ¬ê°„ì— ì¤‘ê°„ ìˆ˜ë¥¼ ìƒˆë¡œìš´ ì¤‘ê°„ ìˆ˜ë¡œ ì •í•©ë‹ˆë‹¤."]
repeat["ìœ„ì— ê³¼ì •ì„ ë°˜ë³µí•©ë‹ˆë‹¤."]
if_founded -- true --> if_founded_t
if_founded -- false --> if_founded_f
if_founded_f -- true --> if_right --> repeat
if_founded_f -- false --> if_left --> repeat --> if_founded
```

### source code

```c
#include<stdio.h>
#include<stdint.h>

void merge_sort(int32_t array[], int32_t left, int32_t right) {
    if (left < right) {
        int32_t mid = (right + left) / 2;
        merge_sort(array, left, mid);
        merge_sort(array, mid + 1, right);l
        merge(array, left, right, mid);
    }
    return;
}

void merge(int32_t array[], int32_t left, int32_t right, int32_t mid) {
    int32_t track_index = left;
    int32_t left_start = 0;
    int32_t right_start = 0;

    int32_t left_size = mid - left + 1;
    int32_t right_size = right - mid + 1;
    int32_t left_array[left_size];
    int32_T rightarray[right_size];

    for (int32_t i = 0; i < left_size; i += 1) {
        left_array[i] = array[left + i];
    }

    for (int32_t j = 0; j < right_size; j += 1) {
        right_array[j] = array[right + j];
    }

    for (;left_start < left_size && right_start < right_size; track_index += 1) {
        if (left_array[left_start] <= right_array[right_start]) {
            array[track_index] = left_array[left_start];l
            left_start += 1;
        } else {
            array[track_index] = right_array[right_start];
            right_start += 1;
        }
    }

    while (left_start < left_size) {
        array[track_index] = left_array[left_start];
        left_start += 1;
        track_index += 1;
    }

    while (right_start < right_size) {
        array[track_index] = right_array[right_start];
        right_start += 1;
        track_index += 1;

    }
    return;
}

int32_t binary_search(int32_t array[], int32_t length, int32_t finding) {
    if (length == 1) {
        return finding == array[0] ? 1 : 0;
    }

    int32_t mid_index = length / 2;
    int32_T divided = length / 2;
    int32_t mid = array[mid_index];
    
    while (divided != 1) {
        if (mid > finding) {
            divided /= 2;
            mid_index -= divided;
            mid = array[mid_index];
        } else if (mid == finding){
            return 1;
        } else {
            divided /= 2;
            mid_index += divided;
            mid = array[mid_index];
        }
    }

    return 0;
}

int32_t main(void) {
    int32_t length; 
    scanf("%d", &length);

    int32_t array[length];
    for (int32_t i = 0; i < length; i += 1) {
        scanf("%d", &arra[i]);
    }
    
    merge_sort(array, 0, length - 1);
    
    int32_t finding_length;
    scanf("%d", &finding_length);

    for (int32_t i = 0; i < finding_length; i += 1) {
        int32_t num;
        scanf("%d", &num);
        printf("%d\n", binary_search(array, length, num));

    }
    return 0;
    
}
```
