---
id: "9953"
aliases: []
tags: []
---

# 💳 문제이해

문자열 s와 폭탄이 문자열이 주어진다. 폭탄 문자열이란, 터지면 문자열이 제거됩니다.
s에서 모든 폭탄 문자열을 제거하고, 남는 문자열이 없을 경우 "FRULA"를 
출력하시고, 있으면 남는 문자열을 출력하세요.

# 🚥 문자접근

주어진 문자열을 스택에 넣을 때마다, 해당 문자가 폭탄 문자인지 검사하면서
넣으면, 스택에 들어간 문자열이 폭탄을 제거한 문자열인 셈입니다.

하지만 해당 문제에 성공률은 26% 밖에 안 됩니다.... 

위에 방법의 시간 복잡도는 최악의 경우 $O(n * 36)$ 입니다.

우선 시도해 볼만한 가치는 있을 거 같습니다.

....

역시 틀렸습니다.

예시 반례는 통과했습니다. 질문 게시판에서 한번 찾아보겠습니다.

문제를 잘못 이해 했습니다.

폭탄 문자가 아니라 폭탄 문자열이었습니다.

현재 스택 문자열이, 폭탄 문자열에 길이를 따라 잡거나 그 이상일 경우
한 번 최신 문자열에서 시작해서 

슥~~~ 폭탄 문자열이 있는 확인해줍니다. 있으면 제거하고, 없으면, 계속해서
문자를 추가합니다.

### source code
```c
#include<stdio.h>
#include<stdint.h>
#include<string.h>
#include<stdlib.h>

#define MAX_CHAR 1000001

typedef struct {
	char* arr;
	int32_t last_idx;
} stack;

int32_t main(void) {
	int32_t n;
	int32_t bomb_len;
	char str[MAX_CHAR];
	char bomb_str[37];
	
	scanf("%s", str);
	scanf("%s", bomb_str);
	n = strlen(str);
	bomb_len = strlen(bomb_str);

	stack a = {
		(char*)malloc((n + 1) * sizeof(char)),
		-1,
	};

	int32_t is_bomb = 1;
	for (int32_t i = 0; i < n; i += 1) {
		a.arr[a.last_idx + 1] = str[i];
		a.last_idx += 1;

		if (a.last_idx >= bomb_len - 1) {
			int32_t temp = a.last_idx;
			for (int32_t j = bomb_len - 1; j >= 0; j -= 1) {
				if (a.arr[temp] != bomb_str[j]) {
					is_bomb = 0;
					break;
				}
				temp -= 1;
			}
			if (is_bomb == 1) {
				for (int32_t i = 0; i < bomb_len; i += 1) {
					a.last_idx -= 1;
				}
			}
			is_bomb = 1;
		}

	}

	if (a.last_idx == -1) {
		printf("FRULA");
	} else {
		a.arr[a.last_idx + 1] = '\0';
		for (int32_t i = 0; i < a.last_idx + 1; i += 1) {
			printf("%c", a.arr[i]);
		}
	}
	return 0;
}
```
