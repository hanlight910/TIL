---
id: "17299"
aliases: []
tags: []
---

# 💳 문제이해

수열 N개가 주어졌을 때, 각 수의 NGF(오등큰수)를 구하세요.
'오등큰수' 란, F(원소)가 해당 원소가 수열의 등장한 횟수라고 하면,
현재 원소 기준 오른쪽에, 왼쪽에서 가장 큰 F(원소)를 오등큰수라고 합니다.
해당 되는 경우가 없으면 -1을 출력하세요.

# 🚥 문제접근

## 예시

```
7
1 1 2 3 4 2 1 
```

- 1의 등장 횟수는 3번 입니다.
- 2의 등장 횟수는 2번 입니다.
- 3의 등장 횟수는 1번 입니다.
- 4의 등장 횟수는 1번 입니다.

1. NFG(1)은 -1 입니다.  
오른쪽에서 F(1)보다 큰 가장 왼쪽에 있는 수는 없으므로 -1을 출력합니다.

2. NFG(2)는 -1입니다.  
1번 과 같은 이유입니다.

3. NFG(3)은 1입니다.  
오른쪽에서 F(2)보다 큰 가장 왼쪽에 있는 수는 F(1) or 3입니다. 따라서 1입니다.

4. NFG(4)는 2번입니다.  
오른쪽에서 F(3)보다 큰 가장 왼쪽에 있는 수는 F(2) or 2입니다. 따라서 2입니다.

...

7. NFG(7)은 -1입니다.  
오른쪽에 수가 더 이상 없으므로 -1을 출력합니다.

## 🛠️ 문제분석

우선 선행조건으로 각 원소의 F(원소), 등장 횟수를 구해야합니다.

근데 가장 효율적인 방법도 그냥 원소를 매핑 식으로 저장해야 할 거 같은데,
그럴 경우 메모리 공간을 쓸데없이 과도하게 할당하는 격이 됩니다.

- 원소갯수[원소] += 1;

그 다음으로는 스택을 사용하여, 현재 원소 기준으로 그 다음의 큰 값을 추적합니다.

크지 않으면 스택에 쌓습니다.

### 🌎 문제해결

#### 💻 source code

```c
#include<stdio.h>
#include<stdint.h>
#include<stdlib.h>

#define MAX_N 1000001

typedef struct {
    int32_t* arr;
    int32_t top_idx;
} stack;

void pop(stack* a) {
    a->top_idx -= 1;
    return;
}

void push(stack* a, int32_t value) {
    a->arr[a->top_idx + 1] = value;
    a->top_idx += 1;
    return;
}

void printf_NFG(int32_t* count_num, int32_t* arr, int32_t length) {
    stack a = {
        .arr = (int32_t*)malloc(length * sizeof(int32_t)),
        .top_idx = -1,
    };

    int32_t NGF[length];

    for (int i = 0; i < length; i += 1) {
        NGF[i] = -1;
    }

    for (int32_t i = 0; i < length; i += 1) {
        while (a.top_idx > -1 && count_num[a.arr[a.top_idx]] < count_num[i]) {
            NGF[a.arr[a.top_idx]] = arr[i];
            pop(&a);
        }

        push(&a, i);
    }

    for (int32_t i = 0; i < length; i += 1) {
        printf("%d ", NGF[i]);
    }
    return;
}

int32_t main(void) {
    int32_t n;
    scanf("%d", &n);

    int32_t count_of_num[MAX_N] = {0};
    int32_t arr[n];
	int32_t count_arr[n];

    for (int32_t i = 0; i < n; i += 1) {
        scanf("%d", &arr[i]);
        count_of_num[arr[i]] += 1;
    }

	for (int i = 0; i < n; i += 1) {
		count_arr[i] = count_of_num[arr[i]];
	}

    printf_NFG(count_arr, arr, n);
    
    return 0;
}
```
