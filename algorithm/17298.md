---
id: "17298"
aliases:
  - 오큰수
tags:
  - stack
  - 스택
---

# 💳 문제이해

크기가 N인 수열이 주어졌을 때, 첫 번째 원소부터 마지막 원속까지의 
오큰수(NGE)를 구하세요. 오큰수가 없으면 -1을 출력하세요.

오큰수(NGE)란 현재 원소 기준으로 오른쪽에 있으면서, 현재 원소 보다 큰
가장 왼쪽에 있는 수를 의미합니다.


# 🚥 문제접근

## 🧪 예시

예를 들어 

```
3 5 2 7
```
수열이 주어졌다고 합니다.

1. 첫 번째 원소인 3의 오른쪽 원소들을 탐색합니다. 5는 3보다 큽니다.
첫 번째 원소의 오큰수는 5입니다.

2. 2는 5보다 작습니다, 7은 5보다 큽니다. 두 번째 원소의 오큰수는 7입니다.
3. 7는 2보다 큽니다. 세 번째 원소의 오큰수는 7입니다.
4. 7은 오른쪽 원소가 없습니다. 오큰수가 없으므로 -1을 출력합니다.

## 💡 생각

첫 번째로 생각나는 건 for문을 두 번 돌려서 전체 탐색을 하는 것입니다.

각 원소를 돌면서, 현재 원소의 다음 원소를 탐색하는 방식입니다.

이는 최악의 경우 시간 복잡도 $O(n^2)$을 기록합니다.

좀 더 효율적인 방법이 있는지 찾아봅니다.

### 시도

현재 원소에서 다음 원소를 찾을 수 있는 방법을 찾아야합니다.

1 번째 원소인 3입장에서는 5를 찾아야 합니다.

각 원소를 순회하자면,

1. 3을 저장합니다.
2. 5는 3보다 큽니다. 5를 NGE 배열에 저장합니다. 3은 이제 필요 없으니 3은 제거합니다.
5를 저장합니다.
3. 2는 5보다 작습니다. 2도 나중에 필요하니, 저장합니다.
4. 7은 5보다 작습니다. 따라서 7은 정답 (NGE)배열에 저장하고, 5는 필요 없으니
제거합니다. 7은 2보다 큽니다. 따라서 7도 정답(NGE)배열에 저장합니다.

6. 7을 넣을려고 하는데, 7은 마지막입니다. 고로 -1를 정답 배열에 저장합니다.

근데, 이러면 최악의 경우 n^2 걸릴 것 같은데요?

우선 구현 해 보겠습니다.

...

문제점을 발견 했습니다. -1을 언제 넣을지에 대한 조건을 찾지 못했습니다.
그러니 정답 배열에 먼저 -1을 채워 넣고, 각 원소의 인덱스에 NGE가 있으면 저장합니다.

#### 예시

```
9 5 4 8
```

1. 현재 스택은 비어 있습니다. 그냥 9를 넣습니다.
2. 5 < 9이므로 5도 연이어 넣습니다.
3. 4를 스택에 마지막 원소와 비교합니다. 4 < 5 작습니다. 4도 넣습니다.
4. 8를 4와 비교합니다. 8 > 4입니다. 4의 NEG은 8입니다.
    - 4의 인덱스에 NEG를 정답 배열에 저장합니다.
    - 나머지 스택에 있는 원소들을 처리합니다.
    - 5 < 8, 따라서 5의 NEG은 8입니다. 5의 인텍스에 8을 저장합니다.
    - 9 > 8, 따라서 아무것도 안합니다.

5와 4는 각 인덱스의 정답 배열에 NEG이 저장되어 있으므로,

```
-1 8 8 -1
```

위와 같은 형식이 나옵니다.

### source code

```c
#include<stdio.h>
#include<stdint.h>
#include<stdlib.h>

typedef struct {
	int32_t* arr;
	int32_t top_idx;
} stack;

int32_t main(void) {
	int32_t n;
	scanf("%d", &n);
	int32_t inputed[n];
	int32_t nge[n];

	for (int i = 0; i < n; i += 1) {
		scanf("%d", &inputed[i]);
		nge[i] = -1;
	}

	if (n == 1) {
		printf("-1\n");
		return 0;
	}

	stack a = {
		(int32_t*)malloc(n * sizeof(int32_t)),
		0,
	};

	a.arr[0] = 0;

	for (int i = 1; i < n; i += 1) {
		while (a.top_idx > -1 && (inputed[a.arr[a.top_idx]] < inputed[i])) {
			nge[a.arr[a.top_idx]] = inputed[i];
			a.top_idx -= 1;
		}

		a.arr[a.top_idx + 1] = i;
		a.top_idx += 1;
	}

	for (int i = 0; i < n; i += 1) {
		printf("%d ", nge[i]);
	}
	
	return 0;
}
```

## 🛠️ 문제 분석

위에 문제는 가장 큰 값을 기준으로, 먼저 들어온 값들이 더 작을 경우 
그 작은 값보다 더 큰 값을 찾는 문제입니다. 이는 나중에 들어온 값을
효과적으로 추적하기 위해 자료 구조 `stack` 후입선출을 사용하였습니다.

### ⏰ 시간복잡도

두 번째 while 문은 상수이므로 포함되지 않습니다.

왜 상수일까요?

실제 while문은 종합적으로 n번 실행 될 것입니다.

스택에 삼입, 제거의 시간복잡도는 $O(1)$입니다. 모든 원소가 들어갔다, 제거
되었을 때 시간 복잡도는 $O(n) + O(n)$ 입니다. 여기서 각 원소를 순회하는 것까지
합치면:
$$ O(n) + O(n) + O(n) $$
입니다. O(n x 3)에서 3은 상수 취급이므로 포함되지 않습니다.

- 시간 복잡도: $O(n)$ 

