---
id: "7562"
aliases: []
tags: []
---

# 💳 문제이해

테스트 케이스 `T`가 주어지면, 각 테스트 케이스인 문제를 해결합니다.
케이스는, 정수 N이 주업니다. 메트릭스를 사이즈 N x N이 있으면,
나이트 위치를 나타내는 쌍이(y, x)이 주어집니다. 인덱스는 0부터 시작합니다.
그 다음에 목표 위치가 위치가 주어집니다. 나이트에 움직임만으로 
목표 위치에 도달하기 위해 필요한 가장 짧은 경로를 구하세요.

# 🚥 문제접근

`bfs`를 쓰면 될 것같습니다. 

## 🛠️ 풀이

### 🌂 BFS

그래프/트리에 너비를 우선적으로 탐색하는 알고리즘입니다. 이는 
동시적으로 각 노드를 탐색하기 때문에, 목표에 도달하는 경로가 
가장 짧은 경로임을 의미합니다.

나이트의 움직이는 자료를 만들어야 합니다.

### 🖥️ source code

```c
#include<stdio.h>
#include<stdint.h>
#include<stdlib.h>

typedef struct {
    int32_t row;
    int32_t col;
} Data;

typedef struct {
    int32_t** visited;
    int32_t** dist;
    int32_t max_row;
    int32_t max_col;
    int32_t min_row;
    int32_t min_col;
} Graph;

typedef struct Node{
    Data val;
    struct Node* next;
    struct Node* head;
} queue;

queue* enqueue(queue* q, Data val) {
    queue* new_q = (queue*)malloc(sizeof(queue));
    (*new_q).val = val;
    (*new_q).next = NULL;

    if (q == NULL) {
        (*new_q).head = new_q;     
    } else {
        (*new_q).head = (*q).head;
        (*q).next = new_q;
    }
    return new_q;
}

Data dequeue(queue** q) {
    Data new_d;

    if (*q != NULL) {
        new_d = (**q).head->val;
        queue* tmp = (**q).head;

        if ((**q).head->next == NULL) {
            (*q) = NULL;
        } else {
            (**q).head = (**q).head->next;
        }
        free(tmp);
    }
    return new_d;
}

_Bool is_valid(Graph* g, Data d) {
    if (
        g->max_row > d.row && d.row >= g->min_row &&
        (g->max_col > d.col && d.col >= g->min_col)
        ) {
        if (!g->visited[d.row][d.col]) {
            return 1;
        }
    }
    return 0;
}

int32_t bfs(Graph g, Data d, Data target) {
    queue* q = NULL;
    int32_t directions[8][2]= {
        { -2, -1 }, // above-left
        { -2, 1 }, // above-right
        { 2, -1 }, // below-left
        { 2, 1 }, // below-right
        { -1, -2 }, // left-above
        { 1, -2 }, // left-below
        { -1, 2 }, // right-above
        { 1, 2 }, // right-below
    };
    
    q = enqueue(q, d);
    g.visited[d.row][d.col] = 1;
    g.dist[d.row][d.col] = 0;

    while (q != NULL) {
        Data cur_d = dequeue(&q);

        for (int32_t i = 0; i < 8; i += 1) {
            Data direct = { directions[i][0] + cur_d.row, directions[i][1] + cur_d.col };
            if (is_valid(&g, direct)) {
                q = enqueue(q, direct); 
                g.visited[direct.row][direct.col] = 1;
                g.dist[direct.row][direct.col] = g.dist[cur_d.row][cur_d.col] + 1;
            }

            if (direct.row == target.row &&
                (direct.col == target.col)) {
                return g.dist[target.row][target.col];
            }
        }
    }

    return g.dist[target.row][target.col];
} 

int32_t main(void) {
    int32_t T;     
    scanf("%d", &T);
    for (int32_t i = 0; i < T; i += 1) {
        int32_t n; 
        Data horse, target;
        scanf("%d", &n);
        scanf("%d %d", &horse.row, &horse.col);
        scanf("%d %d", &target.row, &target.col);
        Graph g = {
            .visited = (int32_t**)malloc(n * sizeof(int32_t*)),
            .dist = (int32_t**)malloc(n * sizeof(int32_t*)),
            .max_row = n,
            .max_col = n,
            .min_row = 0,
            .min_col = 0,
        };
        for (int i = 0; i < n; i += 1) {
            g.visited[i] = (int32_t*)calloc(n, sizeof(int32_t));
            g.dist[i] = (int32_t*)calloc(n, sizeof(int32_t));
        }

        int32_t shortest_path = bfs(g, horse, target);
        printf("%d\n", shortest_path);

        for (int i = 0; i < n; i += 1) {
            free(g.visited[i]);
            free(g.dist[i]);
        }
        free(g.visited);
        free(g.dist);
    }

    return 0;
}
```;
