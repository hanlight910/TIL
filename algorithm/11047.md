---
id: "11047"
aliases: []
tags: []
---

# Reflection

## 💳 문제이해

N 개 줄의 동전의 가치를 나타내는 수들이 오름차순으로 주어질 때,
각 동전 가치의 합이 K가 되도록 필요한 동전 개수의 최소값을 구하세요.

## 🚥 문제접근

오름차순으로 정렬 되어 있기 때문에, 가장 큰 수부터 더하며 K가 될 때까지,
내림차순으로 동전 가치를 더합니다.

이는 각 스테이지마다 최적의 경우를 찾는 그리디 알고리즘을 사용한 방식입니다.

### 1️⃣  문제풀이

- 동전의 가치들을 내림차순으로 더해줍니다.
- 현재 동전의 가치가 K를 초과하지 않을 때까지 계속 더합니다.
- 더하는 과정에서 사용한 동전에 개수를 더합니다.
    - 나누기 연산자를 사용합니다.
- 동전을 사용할 때마다 K를 빼줍니다.
    - 나머지 연산자를 사용합니다.
- 초과 할 거 같으면 다음 동전으로 넘어갑니다.

K가 0이 될 때까지 위에 과정을 반복해줍니다.

이게 가능한 이유는, 가능한 큰 수를 우겨 넣어야 사용되는 수를 줄일 수 있습니다.
이는 현재 단계에서 최적의 경우를 선택하여 동전 사용 개수를 최소하시킵니다.


#### source code
```py
import sys;

inputed_N_K: list[str] = list(sys.stdin.readline().rstrip().split());
N, K = int(inputed_N_K[0]), int(inputed_N_K[1]);

coins: list[int] = [0 for _ in range(0, N)];

for i in range(0, N):
    inputed: str = str(sys.stdin.readline().rstrip());
    coins[i] = int(inputed);

sum: int = 0;
count: int = 0;
index: int = N - 1;

while sum < K:
    if sum + coins[index] > K:
        index -= 1;
    else:
        sum += coins[index];
        count += 1;

print(count);
```

## ⏰ 알고리즘 복잡도
- 시간 복잡도: $O(N)$
    - 최악의 경우
- 공간 복잡도: $O(N)$

## ref
- [백준/11047](https://www.acmicpc.net/problem/11047)
