---
id: "2178"
aliases: []
tags: []
ref:
  - https://www.acmicpc.net/problem/2178
---

# 💳 문제이해

N x M 사이즈의 미로가 주어집니다. 각 원소의 값은 0 혹은 1로 구성 되어 있습니다.
0은 벽, 이동할 수 없는 칸을 의미하고, 1은 지나갈 수 있는 칸을 의미합니다.
이동할 수 있는 방향은 각 칸의 인접한, 좌후 상하로만 이동이 가능합니다.
좌표 (y, x)를 기준으로, (1, 1) 좌측 맨 위에서 시작하였을 때, (N, M)의 
도착하는 과정에서 가장 적은 칸을 이동한 개수를 구하시오.

# 🚥 문제접근

`dfs`, `bfs`로 완전 탐색 할 수 있습니다.

결국엔 모든 경로를 탐색할 필요가 있으므로 가중치가 기본 1 이면서 가장 짧은 경로를
구할 수 있는 `bfs`를 씁니다.

## 🛠️ 문제풀이

### 🌂 BFS

너비 우선 탐색s(BFS, Breadth-First Search)는 같은 깊이에 있는 원소들을 
우선적으로 탐색하는 탐색 알고리즘입니다. 따라서 각 단계에서 
탐색하는 노드의 깊이가 증가하면서 탐색이 이루어지기 때문에, 
목표 노드에 처음 도착했을 때의 경로가 항상 **최단 경로**가 됩니다
`BFS`는 이미 방문한 곳은 다시 탐색하지 않기 때문에, 한 번 방문한 노드에
도달한 경로는 해당 노드로 가는 가장 짧은 경로임을 보장합니다.


```
 1  2  0  8  9  0 
 2  3  0  7  8  0 
 3  4  5  6  7  8 
 4  5  6  7  0  9 
```
위에 행열처럼, 이미 방문한 원소는 다시는 다시는 탐색하지 않습니다.
이는 `BFS`가 동시적으로 모든 경로를 탐색하면서, 처음 도달한 경로가 항상 최단
경로가 된다는 특성입니다

#### ⏰ 시간 복잡도

시간복잡도는 O(V + E)를 기록합니다.
다만 간선의 수는 4 * V인데, 4는 상수이므로 사실상 간선은 O(V)입니다.
따라서 시간복잡도는 O(V)입니다.

### 🖥️ source code

```c
#include<stdio.h>
#include<stdint.h>
#include<stdlib.h>

typedef struct {
    int32_t row;
    int32_t col;
} Data;

typedef struct Node {
    Data val;
    struct Node* head;
    struct Node* next;
} Node;

typedef Node queue;
typedef struct {
    int32_t** graph;
    int32_t** visited;
    const u_int32_t max_row: 32;
    const u_int32_t min_row: 32;
    const u_int32_t max_col: 32;
    const u_int32_t min_col: 32;
	int32_t** dist;
} Maze;

/* Insert val in queue */
queue* enqueue(queue* q, Data val) {
    queue* new = (queue*)malloc(sizeof(queue));
    new->val = val;
    new->next = NULL;
    if (q == NULL) {
        q = new;
        q->head = q;
    } else {
        new->head = q->head;
        q->next = new;
        q = new;
    }
    return q;
}

/* pop val in queue, return val */
Data dequeue(queue** q) {
    if (*q == NULL) {
        Data temp;
		return temp;
    } else {
        queue* temp = (**q).head;
        Data val = (*(**q).head).val;
		if ((*q)->head != NULL && (*(**q).head).next == NULL) {
			*q = NULL; 
		} else {
			(**q).head = (*(**q).head).next;
		}
        free(temp);
		return val;
    }
}

_Bool is_valid(Maze* m, Data val) {
    if (
        m->max_row > val.row && val.row >= m->min_row
        && (m->max_col > val.col && val.col >= (*m).min_col)
        ) {
        if (
			m->graph[val.row][val.col] &&
			!m->visited[val.row][val.col]
			) {
            return 1;
        }
    }
    return 0;
}

int32_t bfs(Maze m, Data val, Data target) {
    queue* q = NULL;
    u_int32_t count = 1;
    int32_t directions[2][4] = {
        { 0, 0, -1, 1 }, // y
        { -1, 1, 0, 0 }, // x
    };
    q = enqueue(q, val);
    m.visited[val.row][val.col] = 1;
	m.dist[val.row][val.col] = 1;

    while (q != NULL) {
        Data row_col = dequeue(&q);

        for (int32_t i = 0; i < 4; i += 1) {
            Data cur_val = {
                row_col.row + directions[0][i],
                row_col.col + directions[1][i],
            };
            
            if (is_valid(&m, cur_val)) {
                m.visited[cur_val.row][cur_val.col] = 1;
                q = enqueue(q, cur_val);
				// printf("row: %d; col: %d\n", cur_val.row, cur_val.col);
				m.dist[cur_val.row][cur_val.col] = m.dist[row_col.row][row_col.col] + 1;
            }
        }
    }
    return m.dist[m.max_row - 1][m.max_col - 1];
}

int32_t main(void) {
    int32_t N, M; 
    scanf("%d %d", &N, &M);
    int32_t min_row = 0;
    int32_t min_col = 0;
    Maze m = {
        .graph = (int32_t**)malloc(N * sizeof(int32_t*)),
        .visited = (int32_t**)malloc(N * sizeof(int32_t*)),
        N,
        min_row,
        M,
        min_col,
        .dist = (int32_t**)malloc(N * sizeof(int32_t*)),
    };

	for (int32_t i = 0; i < N; i += 1) {
		m.graph[i] = (int32_t*)calloc(M, sizeof(int32_t));
		m.visited[i] = (int32_t*)calloc(M, sizeof(int32_t));
		m.dist[i] = (int32_t*)calloc(M, sizeof(int32_t));

		char str[101];
		scanf("%s", str);
		for (int j = 0; j < M; j += 1) {
			m.graph[i][j] = str[j] - 48;
		}
	}

    Data val = {
        0, 0
    };
	Data target = {
		N, M
	};

    u_int32_t count = bfs(m, val, target);
    printf("%d\n", count);
    return 0;
}
```
