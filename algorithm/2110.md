---
id: "2110"
aliases: []
tags: []
---

# ğŸ’³ ë¬¸ì œì´í•´

ì§‘ì˜ ì¢Œí‘œ Nê°œì™€ ê³µìœ  ê°œìˆ˜ Cê°œê°€ ì£¼ì–´ì¡Œì„ ë•Œ, ê° ê³µìœ ê¸°ë¥¼ ì§‘ì—ë‹¤ê°€ ì„¤ì¹˜
í•˜ì˜€ì„ ë•Œ, ê°€ì¥ ì¸ì ‘í•œ ë‘ ê³µìœ ê¸° ì‚¬ì´ì˜ ê±°ë¦¬ë¥¼ ê°€ëŠ¥í•œ í¬ê²Œ í•œ ê±°ë¦¬ë¥¼
êµ¬í•˜ì„¸ìš”.

# ğŸš¥ ë¬¸ì œì ‘ê·¼

ê³µìœ ê¸°ì˜ ê°œìˆ˜ê°€ Nê°œì´ë©´ ê°€ì¥ ì¸ì ‘í•œ ë‘ ê³µìœ ê¸° ì‚¬ì´ì˜ ê±°ë¦¬ë¥¼ ê°€ëŠ¥í•œ í¬ê²Œ í•œ
ê±°ë¦¬ëŠ” 1ì…ë‹ˆë‹¤.

ì´ëŠ” êµ³ì´ ì´ë¶„íƒìƒ‰ì„ í•˜ì§€ ì•Šì•„ë„, ëª¨ë“  ì§‘ì— ì„¤ì¹˜ ëœ ê³µìœ ê¸°ì˜ ê±°ë¦¬ê°€
1ì¸ ê±¸ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ìš°ì„ , ê³µìœ ê¸° ê°„ì˜ ê±°ë¦¬ë¥¼ ì•Œë ¤ë©´, ì •ë ¬ì´ ë˜ì–´ì•¼ í•¨ìœ¼ë¡œ ì •ë ¬ì„ ë¨¼ì € í•©ë‹ˆë‹¤.

```mermaid
flowchart LR
1 --> 2 --> 4 --> 8 --> 9
```

1. íƒìƒ‰ ë²”ìœ„ëŠ” 1ë¶€í„° ìµœëŒ€ ì§‘ì˜ ì¢Œí‘œì…ë‹ˆë‹¤.
2. íƒìƒ‰ ë²”ìœ„ì˜ ì ˆë°˜ì˜ ê±°ë¦¬ë¥¼ ì„¤ì •í•©ë‹ˆë‹¤.
3. ì²« ë²ˆì§¸ ì§‘ì˜ ê³µìœ ê¸°ë¥¼ ì„¤ì¹˜í•˜ì—¬ ì„¤ì •í•œ ê±°ë¦¬ë§Œí¼ ë–¨ì–´ì§„ ì§‘ì— ì„¤ì¹˜ë¥¼ í•©ë‹ˆë‹¤.
ì´ Cê°œ ì„¤ì¹˜í•  ìˆ˜ ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.

4. ê³µìœ ê¸°ë¥¼ ëª¨ë‘ ì„¤ì¹˜ í•  ìˆ˜ ìˆë‹¤ë©´, ê±°ë¦¬ë¥¼ ë” í¬ê²Œ í•  ìˆ˜ ìˆëŠ” í™•ì¸í•˜ê¸°
ìœ„í•´ íƒìƒ‰ ë²”ìœ„ë¥¼ ëŠ˜ë¦¬ê³ , ì„¤ì¹˜í•  ìˆ˜ ì—†ë‹¤ë©´ íƒìƒ‰ ë²”ìœ„ë¥¼ ì¤„ì…ë‹ˆë‹¤.

## ğŸ’¡ ë¬¸ì œí’€ì´ê³¼ì •

1. ì •ë ¬(í•©ë³‘ ì •ë ¬)

ì£¼ì–´ì§„ ì§‘ì˜ ì¢Œí‘œë“¤ì„ í•©ë³‘ ì •ë ¬ì„ ì‚¬ìš©í•´ ì •ë ¬í•©ë‹ˆë‹¤.

```mermaid
flowchart TD
if{"if íƒìƒ‰í•˜ëŠ” ì›ì†Œê°€ 1ê°œë©´"}
more_two["í˜„ì¬ ì›ì†Œì˜ ê°œìˆ˜ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì ˆë°˜ì„<br> ë¶„í• í•©ë‹ˆë‹¤."]

one["ë¶„í• ëœ ë‘ ê°œì˜ ì ˆë°˜, <br>ì™¼ìª½/ì˜¤ë¥¸ìª½ì— ìˆëŠ” ì›ì†Œë¥¼ì„ ë¹„êµí•˜ì—¬ ì •ë ¬í•©ë‹ˆë‹¤."]

if -- true --> one
if -- false --> more_two
```

2. Cê°œì˜ ê³µìœ ê¸°ë¥¼ ì„¤ì¹˜ ê°€ëŠ¥ ì—¬ë¶€ í™•ì¸

```mermaid
flowchart TD
i["i = 1<br>ì§‘[0] = ê³µìœ ê¸°<br>í˜„ì¬ ê³µìœ ê¸° ìœ„ì¹˜ = 0<br>ê³µìœ ê¸° ê°œìˆ˜ = 1"]
if{"i < ì§‘ ê°œìˆ˜ || ê³µìœ ê¸° ê°œìˆ˜ == C"}
if_t{"ìµœëŒ€ ê¸¸ì´ <= ì§‘[i] - ì§‘[í˜„ì¬ ê³µìœ ê¸° ìœ„ì¹˜]"}
long["ê³µìœ ê¸° ê°œìˆ˜ += 1<br>í˜„ì¬ ê³µìœ ê¸° ìœ„ì¹˜ = i"]
loop["i += 1"]

i -- initial --> if -- true --> if_t -- true --> long
if_t -- false --> loop
long --> loop -- loop --> if
if -- false --> is_c{"c == ê³µìœ ê¸° ê°œìˆ˜"} -- true --> true["return True"]
is_c -- false --> false["return false"]

```

3. ì´ë¶„íƒìƒ‰

```mermaid
flowchart TD
initialize["start = 1<br> end = ê°€ì¥ í° ì§‘ì˜ ì¢Œí‘œ"]
start_eqend{"start != end"}
not_eq["mid = (start + end + 1) / 2"]
is_c["is_C = Cê°œ ê³µìœ ê¸° ì„¤ì¹˜ ê°€ëŠ¥ ì—¬ë¶€"]
is_Ccheck{"is_c == true"}
is_Ctrue["start = mid"]
is_Cfalse["end = mid - 1"]
en["return start || end"]


initialize -- initialize --> start_eqend -- true --> not_eq --> is_c
is_c --> is_Ccheck -- true --> is_Ctrue -- loop --> start_eqend
is_Ccheck -- false --> is_Cfalse -- loop --> start_eqend
start_eqend -- false --> en
```

### source code

```c
#include<stdio.h>
#include<stdint.h>

typedef struct {
    int32_t length;
    int32_t* arr;
} Array;

typedef struct {
    int32_t left;
    int32_t right;
    int32_t mid;
} Position;

void merge(const Array const* a, const Position const* b) {
    int32_t left_size = b->mid - b->left + 1;
    int32_t right_size = b->right - (b-> mid + 1) + 1;
    
    int32_t left_arr[left_size];
    int32_t right_arr[right_size];
    for (int32_t i = 0; i < left_size; i += 1) {
        left_arr[i] = a->arr[i + left];
    }
    for (int32_t i = 0; i < right_size; i += 1) {
        right_arr[i] = a->arr[i + mid + 1];
    }

    int32_t index_left = 0;
    int32_t index_right = 0;
    int32_t index_track = left;

    for (; index_left < left_size || index_right < right_size; index_track += 1) {
        if (left_arr[left_size] <= right_arry[right_index]) {
            a->arr[index_track] = left_arr[index_left];
            left_size += 1;
        } else {
            a->arr[index_track] = right_arr[index_right];
            index_right += 1;
        }
    }

    for (;index_left < left_size; index_left += 1, index_trac += 1) {
        a->arr[index_track] = left_arr[index_left];
    }

    for (; index_right < right_size; index_right += 1, index_trac += 1) {
        a->arr[index_track] = right_arr[index_right];
    }

    return;

}

void merge_sort(const Array const * a, const int32_t left, const int32_t right) {
    if (left <= right) {
        int32_t mid = (left + right) / 2;
        merge_sort(Array, left, mid);
        merge_sort(Array, mid + 1, right);
        Position = {
            left, right, mid,
        }
        merge(Array, &Position);
    } 
    return;
}

int32_t is_C(const Array const* a, const int32_t const* C, const int32_t 
*current_difference) {
    int32_t current_network_address = 0;
    int32_t count_network;

    for (int32_t i = 1; i < a->length; i += 1) {
        if (current_difference <= a->arr[i] - a->arr[current_network_address]) {
            current_network_address = i; 
            count_network += 1;
        }

        if (C == count_network) {
            return 1;
        }
    }
    
    return 0;
}

int32_t binary_search(const Array const* a, const int32_t C) {
    merge(Array, 0, a->length - 1);
    int32_t start = 1; 
    int32_t end = a->arr[length - 1];

    while (start != end) {
        int32_t mid = ((int64_t)start + end + 1) / 2;

        int32_t is_c = is_C(a, &C, &mid);

        if (is_c == 1) {
            start = mid;
        } else {
            end = mid - 1;
        }
    }

    return start || end;
}

int32_t main(void) {

    int32_t N, C;
    scanf("%d %d", &N, &C);
    int32_t arr[N];

    for (int32_t i = 0; i < N; i += 1) {
        scanf("%d", &arr[i]);
    }

    Array a = {
        N,
        arr,
    };

    int32_t max_length = binary_search(&a, C);
    return 0;
} 
```
