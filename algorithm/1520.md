---
id: "1520"
aliases: []
tags: []
---

# ðŸ’³ ë¬¸ì œì´í•´

ì£¼ì–´ì§„ ë§¤íŠ¸ë¦­ìŠ¤ëŠ” M x N í¬ê¸°ì´ë©°, ê° ì›ì†ŒëŠ” 10,000 ì´í•˜ì˜ ìžì—°ìˆ˜ì´ë‹¤.
ì²« ë²ˆì§¸ í–‰ì˜ ì²« ë²ˆì§¸ ì—´ì—ì„œ ì¶œë°œí•˜ì—¬ ë§ˆì§€ë§‰ í–‰ì˜ ë§ˆì§€ë§‰ ì—´ë¡œ ì´ë™í•˜ë ¤ê³  í•©ë‹ˆë‹¤.
ì´ë™í•  ìˆ˜ ìžˆëŠ” ë°©í–¥ì€ ìƒí•˜ì¢Œìš°ì´ë©°, ë‹¤ìŒ ì´ë™í•˜ë ¤ëŠ” ìœ„ì¹˜ì˜
ì›ì†Œ ê°’ì€ í˜„ìž¬ ìœ„ì¹˜ì˜ ì›ì†Œ ê°’ë³´ë‹¤ ìž‘ì•„ì•¼ í•©ë‹ˆë‹¤. ì´ëŸ¬í•œ ì¡°ê±´ì„ ë§Œì¡±í•˜ë©´ì„œ
ì˜¤ë¥¸ìª½ ì•„ëž˜ ë ì›ì†Œê¹Œì§€ ë„ë‹¬í•  ìˆ˜ ìžˆëŠ” ëª¨ë“  ê²½ë¡œì˜ ê²½ìš°ì˜ ìˆ˜ë¥¼ êµ¬í•˜ì‹œì˜¤.

# ðŸš¥ ë¬¸ì œì ‘ê·¼

ì´ëŸ¬í•œ ëª¨ë“  ê²½ìš°ì˜ ìˆ˜ë¥¼ íƒìƒ‰í•˜ëŠ” ë°©ë²•ì„ BFS, DFSë¥¼ ì‚¬ìš©í•œë‹¤ê³  ì•Œê³  ìžˆë‹¤.

ìš°ì„  ìž‘ì€ ì¼€ì´ìŠ¤ë¡œ í’€ì–´ë³´ë ¤ê³  í•œë‹¤. 

## 2 x 2

x / y | 0 | 0
:---:|:---:|:---:
0 | 50 | 45
0 | 35 | 20

ìœ„ì™€ ê°™ì´ ê°™ì´ 2 x 2ì¼ ë•ŒëŠ”

1. 50ì—ì„œ ì¶œë°œí•œë‹¤. 45, 35 ëª¨ë‘ 50ë³´ë‹¤ ìž‘ë‹¤ ê°ˆ ìˆ˜ ìžˆëŠ” ì›ì†Œì´ë‹¤.
2. 45ì˜ ìš°ì¸¡ ì›ì†ŒëŠ” ì—†ìœ¼ë¯€ë¡œ, ì•„ëž˜ìª½ ì›ì†Œì˜ ê°’ì¸ 20ì€ 45ë³´ë‹¤ ìž‘ë‹¤. ê³ ë¡œ 
ì´ ê²½ë¡œëŠ” ì¡°ê±´ì— ë§Œì¡±í•˜ë¯€ë¡œ ê²½ë¡œì˜ ê²½ìš°ì˜ ìˆ˜ì— ì¶”ê°€í•œë‹¤.
3. ë§ˆì°¬ê°€ì§€ë¡œ 35ëŠ” ë‹¤ìŒ ì›ì†Œê°€ 20ë°–ì— ì—†ë‹¤ 20ì€ 35ë³´ë‹¤ ìž‘ìœ¼ë¯€ë¡œ, ê°ˆ ìˆ˜ ìžˆë‹¤.
ë”°ë¼ì„œ ì´ ê²½ë¡œë„ ì¶”ê°€í•œë‹¤.

ê²°ê³¼ì ìœ¼ë¡œ, ëª¨ë“  ê²½ë¡œì˜ ê²½ìš°ì˜ ìˆ˜ëŠ” 2ì´ë‹¤.

2 x 2ëŠ” ê²½ìš°ì˜ ìˆ˜ê°€ ì ì–´ ì°¸ê³ ê°€ ì•ˆ ëœë‹¤.
ì•„ë¬´íŠ¼ ì´ëŸ° ì‹ìœ¼ë¡œ í•  ê²ƒì´ë‹¤.

## 3 x 3
x / y | 0 | 0 | 0
:---:|:---:|:---:|:--:
0 | 50 | 45 | 37 
0 | 35 | 20 | 25
0 | 30 | 21 | 5

50ì—ì„œ ì‹œìž‘í•´ì„œ 5ì— ë„ì°©í•´ì•¼ í•œë‹¤.

1. ì˜¤ë¥¸ìª½, ì™¼ìª½ ëª¨ë‘ 50ë³´ë‹¤ ìž‘ë‹¤.
    1. 45ì˜ ì˜¤ë¥¸ìª½ ì•„ëž˜ëŠ” 45ë³´ë‹¤ ìž‘ë‹¤.
        1. 37ì˜ ì•„ëž˜ëŠ” 37ë³´ë‹¤ ìž‘ë‹¤.
            1. 25ì˜ ì•„ëž˜ëŠ” 25ë³´ë‹¤ ìž‘ë‹¤.
                - ë„ì°©
        2. 20ì€ ì˜¤ë¥¸ìª½, ì™¼ìª½, ì•„ëž˜ëŠ” ëª¨ë‘ 20ë³´ë‹¤ í¬ë‹¤
            - ì¢…ë£Œ
    2. 35ì˜ ì˜¤ë¥¸ìª½ì€ ì˜¤ë¥¸ìª½ ì•„ëž˜ëŠ” 35ë³´ë‹¤ ìž‘ìŠµë‹ˆë‹¤.
        - í•˜ì§€ë§Œ ì˜¤ë¥¸ìª½ì¸ 20ì€ ì´ë¯¸ íƒìƒ‰í•œ ì ì´ ìžˆìŠµë‹ˆë‹¤. ê²°ê³¼ ê½ìž…ë‹ˆë‹¤.
        1. 30ì˜ ì˜¤ë¥¸ìª½ì€ 30ë³´ë‹¤ ìž‘ìŠµë‹ˆë‹¤.
            1. 21ì˜ ì˜¤ë¥¸ìª½ì€ 21ë³´ë‹¤ ìž‘ìŠµë‹ˆë‹¤.
                - ë„ì°©

ê³ ë¡œ ê²°ê³¼ëŠ” ë„ì°©ì´ ë‘ë²ˆ, ê½ì´ í•œë²ˆ ìž…ë‹ˆë‹¤.

ê°€ìš´ë° ì›ì†Œê°€ ì•„ë¬´ë°ë„ ê°ˆ ìˆ˜ ì—†ì–´ì„œ ë‚˜ì˜¬ ìˆ˜ ìžˆëŠ” ê²½ë¡œì˜ ìˆ˜ê°€ ìž‘ìŠµë‹ˆë‹¤.

ìœ„ì—ì²˜ëŸ¼ í’€ë©´ ë  ê²ƒ ê°™ìŠµë‹ˆë‹¤.

dfsë°©ì‹ì²˜ëŸ¼ ê¹Šì´ë¥¼ ë¨¼ì € íƒìƒ‰í•˜ì—¬ 20ê³¼ ê°™ì€ ì›ì†ŒëŠ” ê½ìœ¼ë¡œ ì €ìž¥í•˜ë©´ì„œ,
ë‹¤ìŒ ì›ì†Œì˜ ê¹Šì´ ë•Œ ë‹¤ì‹œ ì—°ì‚° í•  í•„ìš”ê°€ ì—†ìŠµë‹ˆë‹¤.

íƒìƒ‰ ë²”ìœ„ëŠ” ìƒí•˜ì¢Œìš°ë¡œ í•˜ê³ , ë§¨ ëì— ìžˆëŠ” ì›ì†Œë“¤ì€ ë°”ê¹¥ ì›ì†Œë“¤ì„ ë¹„êµí•˜ì—¬
ìž„ì˜ë¡œ ìµœëŒ€ê°’ì„ ì±„ì›ë‹ˆë‹¤.

ëª©í‘œì— ë„ì°©í–ˆìœ¼ë©´ dfs íŠ¹ì„±ì¸ ì´ì „ì— ê±°ì³¤ë˜ ë…¸ë“œë“¤ì— 1ì„ ì¶”ê°€í•©ë‹ˆë‹¤.

ë‹¤ì‹œ íƒìƒ‰í•˜ëŠ” ë…¸ë“œê°€ 0ë³´ë‹¤ í´ ê²½ìš° ì´ë¯¸ ê±°ì³¤ë˜, ì¦‰ ëª©í‘œì— ë„ë‹¬í•œ ê²Œ ë³´ìž¥
ë˜ë¯€ë¡œ í•´ë‹¹ ê°’ì„ ì´ì „ ë…¸ë“œì— ì¶”ê°€í•©ë‹ˆë‹¤.

í•´ë‹¹ ë…¸ë“œì— 3ì´ ë“¤ì–´ê°€ ìžˆë‹¤ë©´, í•´ë‹¹ ê²½ë¡œë¡œ ì„œë¡œ ë‹¤ë¥¸ 3ë²ˆì˜ ê²½ë¡œë¡œ ëª©í‘œì— 
ë„ë‹¬ í•  ìˆ˜ ìžˆë‹¤ëŠ” ê²ƒì„ ì˜ë¯¸í•©ë‹ˆë‹¤.

## ðŸ’¡ ë¬¸ì œí’€ì´ 

```mermaid
flowchart TD

currentHaveValue{"if í˜„ìž¬ ì›ì†Œì— ì´ë¯¸ ê²½ë¡œ íšŸìˆ˜ê°€ ì¡´ìž¬í•˜ë©´"}
currenHave["í˜„ìž¬ íšŸìˆ˜ ëŒë ¤ì£¼ê¸°"]

search_LRTD["í˜„ìž¬ìœ„ì¹˜íšŸìˆ˜ì˜ ì €ìž¥ = ìƒí•˜ì¢Œìš° íƒìƒ‰í•œ ê²°ê³¼"]

end_condition{"í˜„ìž¬ ìœ„ì¹˜ê°€ ë§ˆì§€ë§‰ ì›ì†Œì¼ ê²½ìš°"}
End["ê²½ë¡œ ì´ í•©ì˜ 1ì„ ë”í•©ë‹ˆë‹¤."]

end_condition -- true --> End
end_condition -- false --> currentHaveValue
currentHaveValue -- true --> currenHave
currentHaveValue -- false --> search_LRTD
```

### source code

```c
#include<stdio.h>
#include<stdint.h>
#include<stdlib.h>

typedef struct {
	int32_t x;
	int32_t y;
	int32_t **mat;
	int32_t **dp;
	int32_t (*coord)[4];
	int32_t *N;
	int32_t *M;
} Matrix;

// void print_matrix(int32_t** a, int32_t N, int32_t M) {
// 	printf("-------------\n");
// 	for (int i = 0; i < M; i += 1) {
// 		for (int j = 0; j < N; j += 1) {
// 			printf("%2d ", a[i][j]);
// 		}
// 		printf("\n");
// 	}
// 	return;
// }

int32_t dfs(Matrix a) {
	int32_t x = a.x;
	int32_t y = a.y;

	if (x == *a.N && y == *a.M) {
		return 1; 
	}

	if (a.dp[y][x] != -1) {
		return a.dp[y][x];
	}

	a.dp[y][x] = 0;

	int32_t value = 0;
	for (int32_t i = 0; i < 4; i += 1) {
		if ((1 <= x && x < *a.N + 1) && (1 <= y && y < *a.M + 1)) {
			if (a.mat[y + a.coord[1][i]][x + a.coord[0][i]] < a.mat[y][x]) {
				Matrix new =  {
					x + a.coord[0][i],
					y + a.coord[1][i],
					a.mat,
					a.dp,
					a.coord,
					a.N,
					a.M,
				};
				value = dfs(new);
				a.dp[y][x] += value;
			}

		}
	}

	return a.dp[y][x];
}

void input_matrix(int32_t x, int32_t y, int32_t** a) {
	for (int i = 1; i < y + 1; i += 1) {
		for (int j = 1; j < x + 1; j += 1) {
			scanf("%d", &a[i][j]);
		}
	}
	return;
}

int32_t** allocate_double_array(int32_t M, int32_t N) {
	int32_t** a = (int32_t**)malloc(M * sizeof(int32_t*));
	for (int i = 0; i < M; i += 1) {
		a[i] = (int32_t*)calloc(N, sizeof(int32_t));
	}
	return a;
}
int32_t main(void) {
	int32_t N, M;
	scanf("%d %d", &M, &N);
	int32_t (*coord)[4];
	int32_t** a = allocate_double_array(M + 2, N + 2);
	int32_t** dp = allocate_double_array(M + 2, N + 2);
	int32_t coords[2][4] = {
		{0, 0, -1, 1},
		{-1, 1, 0, 0},
	};

	input_matrix(N, M, a);


	for (int i = 0; i < M + 2; i += 1) {
		for (int j = 0; j < N + 2; j += 1) {
			if (i == 0 || j == 0 || i == M + 1 || j == N + 1) {
				dp[i][j] = -1;
				a[i][j] = 10000;
			} else {
				dp[i][j] = -1;
			}
		}
	}

	coord = coords;

	Matrix m = {
		1, 1, a, dp, coord, &N, &M,

	};
	int32_t count_way = dfs(m);
	printf("%d\n", count_way);

	return 0;
}
```
