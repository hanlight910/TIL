---
id: "2667"
aliases: []
tags:
  - dfs
  - matrix
  - graph_traversal
ref:
  - https://www.acmicpc.net/problem/2667
---

# 💳 문제이해

N x N의 메트릭스가 주어집니다. 각 원소는 0 혹은 1로 구성 되어 있습니다.
연결된 원소의 개수와, 각 연결된 원소의 수를 오름차순으로 구하시오.

여기서 연결된 원소란 좌우, 상하로 1로 연결된 원소들을 말합니다.

# 🚥 문제접근

이해를 돕기 위해 예제를 풀어봅니다.

**예제**
```
0110100
0110101
1110101
0000111
0100000
0111110
0111000
```
위와 같이 메트릭스가 주어졌을 때, 연결된 원소는 3개로, 개수는 오름차순으로
7, 8, 9인 것을 확인 할 수 있습니다.

컴퓨터가 각 연결이 끊긴 구간을 기준으로 하나의 객체로서 인식을 함과 동시에
구별을 해야 하여 원소의 개수를 저장해야 합니다.

`dfs`를 통해 0, 1구간을 구별한다고 하여도, 컴퓨터 입장에서는 다른 연결된
구간을 탐색하였을 때, 전에 발견했던 구간이랑 구별할 조건을 주어야 합니다.

이는 결과적으로 `brute force`로 모든 원소를 탐색할 필요성을 시사합니다.
행열의 좌표를 기준으로 컴퓨터는 연결된 구간을 구별 할 것입니다.

## 🌏 분석

1로 만 연결된 구간을 찾는 것은 어렵지 않습니다. 하지만 여러개의 구간을 찾을려면
이를 구별해야 합니다. 그래서 `brute force`로 모든 원소를 탐색함과 동시에, 
행열을 좌표로 각 구간을 구별합니다. 

모든 원소를 순회할 때 1이 발견된다면, 해당 좌표를 `dfs`를 겁니다. 1로만 연결된
구간을 탐색할 것입니다. 그리고 순회할 때, 해당 원소가 이미 방문 되었다면, 
넘어갑니다. 이를 모든 원소의 적용합니다.

## 🛠️ 풀이

**자료 구조**:

- 2차원 배열을 사용하여 메트릭스(행열)을 표현합니다.
- 방문 배열

### ⚜️  dfs

좌우, 상하를 탐색합니다.

1이면 해당 원소를 기준으로 계속 탐색합니다. 0이면 탐색을 멈춥니다.

### 🥖 brute force 

행열의 모든 원소를 탐색합니다. 해당 원소가 1이면, 해당 원소가 이미 방문 되었는지
확인합니다. 안 되어 있으면, `dfs`를 사용해 연결된 구간을 찾습니다.

## 🌓 후기

재귀에만 의지한 나머지 인접한 노드를 어떻게 추적해야 하는지 적지 않은 시간을
고민 했습니다.

스택에 익숙치 않다 보니 쌓인 스택의 있는 원소를 어떻게 다룰지도 잘 몰랐습니다.

시간 복잡도는 아무래도, 정렬하는 알고리즘이 가장 많이 잡아먹어서 
최악의 경우 `qsort`의 최악의 케이스를 기록할 것 같습니다.

```cpp
#include<stdio.h>
#include<stdint.h>
#include<stdlib.h>

typedef struct {
    int32_t** arr;
    int32_t* max_row;
    int32_t* max_col;
    int32_t* min_row;
    int32_t* min_col;
    int32_t** visited;
} Mat;

typedef struct Node {
    int32_t row;
	int32_t col;
    struct Node* next;
    struct Node* back;
} Node;

typedef Node stack;

stack* create(stack* a, int32_t row, int32_t col) {
    stack* new = (stack*)malloc(sizeof(stack));
	new->row = row;
	new->col = col;
    new->next = NULL;
    new->back = NULL;
    return new;
}

stack* push(stack* a, int32_t row, int32_t col) {
    if (a == NULL) {
        return create(a, row, col);
    }
    stack* new = (stack*)malloc(sizeof(stack));
	new->row = row;
	new->col = col;
    new->next = a->next;
    new->back = a;
    return new;
}

stack* pop(stack* a) {
    if (a == NULL) {
        return a;
    }
    stack* temp = a;
    a = a->back;
    free(temp);
    return a;
}

int32_t is_valid(Mat* m, int32_t row, int32_t col) {
	if (
			(*m->max_row > row && *m->max_col > col)
			&& (*((*m).min_row) <= row && *m->min_col <= col)
			) {
		if (m->arr[row][col] && !m->visited[row][col]) {
			return 1;
		}
	}
	return 0;
}

int32_t dfs(Mat* a, int32_t row, int32_t col) {
    stack* s = NULL;
	int32_t count = 1;
    int32_t directions[2][4] = {
        {0, 0, -1, 1},
        {-1, 1, 0, 0},
    };
    s = create(s, row, col);
    a->visited[row][col] = 1;

    while (s != NULL) {
		int32_t new_row = s->row;
		int32_t new_col = s->col;
		s = pop(s);

		for (int32_t i = 0; i < 4; i += 1) {
			int32_t dr_row = new_row + directions[0][i];
			int32_t dr_col = new_col + directions[1][i];
			if (is_valid(a, dr_row, dr_col)) {
				s = push(s, dr_row, dr_col);
				a->visited[dr_row][dr_col] = 1;
				count += 1;
			}
		}
    }

	return count;
}
int32_t compare(const void* a, const void* b) {
	return *(int32_t*)a - *(int32_t*)b;
}

int32_t main(void) {
    int32_t N;
	scanf("%d", &N);
	int32_t count[625];
	int32_t idx_cnt = 0;
	int32_t min = 0;
	Mat a = {
		.arr = (int32_t**)malloc((N) * sizeof(int32_t*)),
		.min_col = &min,
		.min_row = &min,
		.max_col = &N,
		.max_row = &N,
		.visited = (int32_t**)malloc(N * sizeof(int32_t*)),
	};
    for (int32_t i = 0; i < N; i += 1) {
		a.visited[i] = (int32_t*)calloc(N, sizeof(int32_t));
		a.arr[i] = (int32_t*)calloc(N, sizeof(int32_t));
		char num[N];
		scanf("%s", num);
		for (int32_t j = 0; j < N; j += 1) {
			a.arr[i][j] = num[j] == '0' ? 0 : 1; 
		}
    }

	for (int32_t i = 0; i < N; i += 1) {
		for (int32_t j = 0; j < N; j += 1) {
			if (a.arr[i][j] && !a.visited[i][j]) {
				count[idx_cnt++] = dfs(&a, i, j);
			}
		}
	}
	qsort(count, idx_cnt, sizeof(int32_t), compare);
	printf("%d\n", idx_cnt);
	for (int32_t i = 0; i < idx_cnt; i += 1) {
		printf("%d\n", count[i]);
	}
    return 0;
}
```
