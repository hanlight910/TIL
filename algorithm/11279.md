---
id: "11279"
aliases: []
tags: []
---

# 💳 문제이해

N개의 수가 주어졌을 때, 수가 0이 아니면 힙에 추가합니다.
수가 0이라면 현재 힙에서 가장 큰 값을 출력하고,
그 값을 제거합니다.

# 🚥 문제접근

힙을 사용해 부모 노드의 값이 가장 큰 값이 되도록 구조를 짭니다.

- 힙 삼입
    - 힙의 원소가 0이면, 루트 노드에 삼입합니다. 마지막 노드 뒤에
    삼입합니다.
- 힙 내림차순 정렬
    - 1차원 배열을 사용한다면, 힙의 부모 인덱스는 (자식 인덱스 - 1) / 2
    입니다. 부모 노드 값이 자식 노드 값보다 크면 바꿉니다. 이를
    루트 노드까지 반복합니다.

- 힙 루트 노드 내보내기
    - 루트 노드 저장
    - 루트 노드 마지막 노드의 값 할당.
    - 자식 노드 인덱스 왼쪽(부모 노드 인덱스 * 2 + 1)
    - 자식 노드 인덱스 오른쪽(부모 노드 인덱스 * 2 + 2)
    - 자식 노드의 값이 부모 노드의 값보다 크면, 바꾸기

## 💡 문제풀이

```c
#include<stdio.h>
#include<stdint.h>
#include<stdlib.h>

typedef struct {
    int32_t* arr;
    int32_t size;
} heap;

void insert(heap* a, int32_t value) {
    a->arr[a->size] = value;
    a->size += 1;
    return; 
}
void swap(int32_t* a, int32_t* b) {
    int32_t temp = *a;
    a[0] = *b;
    *b = temp;
    return;
}

void heapify_up(heap* a) {
    for (int32_t index = a->size - 1; i >= 0; i = (i - 1) / 2) {
        int32_t index_parent_node = (index - 1) / 2;
        if (a->arr[index_parent_node] < a->arr[index]) {
            swap(arr->arr[index_parent_node], a->arr[index]);

        }
    }
    return;
}

void heapify_down(heap* a) {
    int32_t parent_node = 0;
    int32_t max_node_index = parent_node;
    
    while (a->size >= (max_node_index * 2 + 1) &&
        parent_node = max_node_index;
        a->size >= (max_node_index * 2 + 2)) {
        int32_t left_node_index = (2 * max_node_index) + 1;
        int32_t right_node_index = (2 * max_node_index) + 2;

        if (a->arr[left_node_index] > a->arr[max_node_index]) {
            max_node_index = left_node_index;
        }

        if (a->arr[right_node_index] > a->arr[max_node_index]) {
            max_node_index = right_node_index;
        }

        if (max_node_index != parent_node) {
            swap(&a->arr[parent_node], &a->arr[max_node_index]);
        }
        
    }

    return;
}

int32_t extract_max_node(heap* a) {
    if (a->size == 0) {
        return 0;
    }
    
    int32_t max_node = a->arr[0];
    a->arr[0] = a->arr[a->size];
    a->size -= 1;
    heapify_down(a);

    return max_node;
}

int32_t main(void) {
    int32_t n; 
    scanf("%d", &n);
    heap a = {
        (int32_t*)malloc(n * sizeof(int32_t)),
        0,
    };
    
    int32_t num;
    for (int32_t i = 0; i < n; i += 1) {
        scanf("%d", &num);

        if (num != 0) {
            insert(a, num);
            heapify_up(a);
        } else {
            int32_t max_node = extract_max_node(a); 
            printf("%d\n", max_node);
        }
    };
    return 0;
}
```
