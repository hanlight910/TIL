---
id: "1992"
aliases: []
tags: []
---

# 💳 문제이해

주어진 메트릭스에서 흑백을 압축하여 표현하는 데이터 구조로 쿼드 트리(Quad Tree)
라는 방법이 있습니다. 흰 점을 나타내는 0과 검은 점을 나타내는 1로만 이루어져
있으며 같은 숫자의 점들이 한 곳에만 몰려 있으면 이를 압축하여 "(통일된 원소)"
식으로 표현해주세요.
    
# 🚥 문제접근


## 1️⃣  문제풀이

1. 처음 N * N 사이즈의 이차원 배열을 전체 탐색합니다.
모든 원소가 0, 1중 하나로 통일 되어 있다면, 해당 원소(0 아니면 1)을 "(원소)"
형식으로 출력해주세요.

2. 통일 되어 있지 않으면, (N / 2) * (N / 2)부분 메트릭스(행과열)를 현재 N * N
메트릭스에서 분할하여 각각 분할한 메트릭스에서 첫번째 순서를 반복합니다.


### source code

```c
#include<stdio.h>
#include<stdint.h>

void input(int32_t length, int32_t a[][length]) {
	char str[length];
    for (int32_t i = 0; i < length; i += 1) {
		scanf("%s", str);
        for (int32_t j = 0; j < length; j += 1) {
			a[i][j] = str[j] - 48;
        }
    }
    return;
}

void print_quad_tree(int32_t length, int32_t a[][length], int32_t x, int32_t y, int32_t N) {

	if (N == 1) {
		printf("%d", a[x][y]);
		return;
	}
	int32_t white = 0;
    for (int32_t i = x; i < N + x; i += 1) {
		for (int32_t j = y; j < N + y; j += 1) {
			if (a[i][j] == 0) {
				white += 1;
			}
		}
	}

	if (white == N * N) {
		printf("%d", 0);
	} else if (white == 0) {
		printf("%d", 1);
	} else {
		printf("(");
		print_quad_tree(length, a, x, y, N / 2);
		print_quad_tree(length, a, x, y + N / 2, N / 2);
		print_quad_tree(length, a, x + N / 2, y, N / 2);
		print_quad_tree(length, a, x + N / 2, y + N / 2, N / 2);
		printf(")");
	}

	return;
}

int32_t main(void) {
	int32_t length;
	scanf("%d", &length);

	int32_t a[length][length];

	input(length, a);
	print_quad_tree(length, a, 0, 0, length);
    return 0;
}
```
