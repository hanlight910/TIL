---
id: "7569"
aliases: []
tags: []
ref:
  - https://www.acmicpc.net/problem/7569](https://www.acmicpc.net/problem/7569
---

# 💳 문제이해

N * M * H 의 3차원 상자가 주어집니다. 각 단위는 너비 M, 길이 N, 높이 H입니다.
N * M으로 이루어진 격자모양 상장행렬에서 각 칸(원소)에는 익은 토마토와, 익지 
않은 토마토, 혹은 비어 있습니다. 익은 토마토를 기준으로 위 아래, 왼쪽 오른쪽, 
앞 뒤 방향으로 인접한 익지 않은 토마토가 있으면 다음 날이 되면 토마토는 
익습니다. 상자 안에 모든 익지 않은 토마토를 익기 위해 필요한 최소 일수를 
구하세요. 만약에 필요한 일수를 지나더라도, 익지 않은 토마토가 있으면, 
-1를 출력하시오.

# 🚥 문제접근


## 🌏 분석

3차원 공간을 이용한다는 거 빼고는 차이점을 못 느낍니다.

토마토 밭의 연장선입니다. 이번엔 3차원 형태인 상자(큐브)입니다. 따라서, 
토마토 여부를 큐브 형태를 표현할 수 있는 3차원 배열을 씁니다.

인접한 방향은 4개에서 6개로 늘어납니다. 좌표는 너비(x), 길이(y)에서 높이(z)를
추가합니다.

마찬가지로 최단 거리를 구하기 위해 탐색 방법중 하나인 `BFS`를 사용합니다.

## ⚒️  풀이

### 🌂 BFS

트리/그래프에서 최단 거리를 구하는데에 적합한 너비를 우선적으로 탐색하는
`BFS` 방법을 사용합니다.

각 노드의 인접한 정점(노드), 간선은 최대 6입니다. 

3차원 배열에서 토마토의 존재 여부를 우선적으로 `stack`에 저장한 후, 동시에
너비를 탐색합니다. 다만 3차원 배열이므로 시간복잡도는 $O(N * M * H)$임을
유의해야 합니다.

### 🥖 Brute force

모든 원소를 탐색하면서, 토마토의 여부를 확인합니다.

#### 🖥️ source code

```c
#include<stdio.h>
#include<stdint.h>
#include<stdlib.h>

#define ln() printf("\n");

typedef struct {
    uint64_t ***visited; 
    uint64_t ***dist;
    int32_t max_ht;
    int32_t max_row;
    int32_t max_col;
} Graph;

typedef struct {
    int32_t ht; // height
    int32_t row;
    int32_t col;
} Data;

#define DEFINE_DATA(z, y, x, val) val.row = y, val.col = x, val.ht = z; 
#define DEFINE_DIRECTIONS(direction) Data direction[6] = { \
    { 0, 0, -1 },  \
    { 0, 0, 1 }, \
    { 0, -1, 0 }, \
    { 0, 1, 0 }, \
    { -1, 0, 0 }, \
	{ 1, 0, 0 }, \
};

#define ADD_DIRECTIONS(coord, direction) Data cur_d = { \
    coord.ht + direction.ht, \
    coord.row + direction.row, \
    coord.col + direction.col, \
};

typedef struct Node {
    Data val;
    struct Node* next;
    struct Node* head;
} queue;

int32_t enqueue(queue** q, Data val) {
    queue* new_q = (queue*)malloc(sizeof(queue));
    new_q->val = val;
    new_q->next = NULL;

    if (*q == NULL) {
        new_q->head = new_q;
        *q = new_q;
    } else {
        new_q->head = (*q)->head;
        (**q).next = new_q;
        *q = new_q;
    }
    return 0;
}

Data dequeue(queue** q) {
    // deleting the head
    // head is next of head
    Data val;
    if (*q != NULL) {
        val = (*(**q).head).val;
        queue* temp = (**q).head; // to free the head

        // if the queue contains only one element
        if ((*(**q).head).next == NULL) {
            *q = NULL;
        } else {
            (**q).head = (*(**q).head).next;
        }
        free(temp);
    }
    return val;
}

_Bool is_valid(Graph* g, Data val) {
    if (
        (*g).max_ht > val.ht && val.ht >= 0 &&
        ((*g).max_row > val.row && val.row >= 0) &&
        ((*g).max_col > val.col && val.col >= 0)
       )  {
        if ((*g).visited[val.ht][val.row][val.col] == 0) {
            return 1;
        }
    }
    return 0;
}

uint64_t get_val_from_3rd_dimention(uint64_t **arr[], Data v) {
    return arr[v.ht][v.row][v.col];
}

queue* initial_queue(Graph* g) {
	queue* q = NULL;

	for (int32_t i = 0; i < g->max_ht; i += 1) {
		for (int32_t j = 0; j < g->max_row; j += 1) {
			for (int32_t k = 0; k < g->max_col; k += 1) 
			if (g->visited[i][j][k] == 1) {
				Data val;
				DEFINE_DATA(i, j, k, val);
				enqueue(&q, val);
			}
		}
	}

	return q;
}

uint64_t BFS(Graph g) {
	queue* q = initial_queue(&g);


    DEFINE_DIRECTIONS(directions);

    uint64_t max_path = 0;

    while (q != NULL) {
        Data cur_c = dequeue(&q);
        for (int32_t i = 0; i < 6; i += 1)  {
            ADD_DIRECTIONS(cur_c, directions[i]);
			// printf("ht: %d; row: %d; col: %d\n", cur_d.ht, cur_d.row, cur_d.col);
            if (is_valid(&g, cur_d)) {
                enqueue(&q, cur_d);
                *(*(*(g.visited + cur_d.ht) + cur_d.row) + cur_d.col) = 1;
                g.dist[cur_d.ht][cur_d.row][cur_d.col] = 
                    get_val_from_3rd_dimention(g.dist, cur_c) + 1;

                uint64_t cur_path = get_val_from_3rd_dimention(g.dist, cur_d);
				// printf("cur_path: %ld\n", cur_path);
                if (max_path < cur_path) {
                    max_path = cur_path;
                }
            }
        }
    }
    return max_path;
}

uint64_t*** allocate_3rd_dimenstion(int32_t N, int32_t M, int32_t H) {
	uint64_t*** n = (uint64_t***)malloc(H * sizeof(uint64_t**));
	for (uint64_t i = 0; i < H; i += 1) {
		*(n + i) = (uint64_t**)malloc(N * sizeof(uint64_t*));
		for (uint64_t j = 0; j < N; j += 1) {
			*(*(n + i) + j) = (uint64_t*)calloc(M, sizeof(uint64_t));
		}
	}
	return n;
}

int32_t input(int32_t N, int32_t M, int32_t H, uint64_t*** arr) {
	for (int32_t i = 0; i < H; i += 1) {
		for (int32_t j = 0; j < N; j += 1) {
			for (int32_t k = 0; k < M; k += 1) {
				scanf("%ld", *(*(arr + i) + j) + k);
			}
		}
	}	
	return 0;
}

int32_t print(int32_t N, int32_t M, int32_t H, uint64_t*** arr) {
	for (int32_t i = 0; i < H; i += 1) {
		for (int32_t j = 0; j < N; j += 1) {
			for (int32_t k = 0; k < M; k += 1) {
				printf("%2ld ", *(*(*(arr + i) + j) + k));
			}
			ln();
		}
		ln();
	}	
	return 0;
}

_Bool is_no_zero(Graph* g) {
	for (int i = 0; i < g->max_ht; i += 1) {
		for (int j = 0; j < g->max_row; j += 1) {
			for (int32_t k = 0; k < g->max_col; k += 1) {
				Data val;
				DEFINE_DATA(i, j, k, val);
				if (!get_val_from_3rd_dimention(g->visited, val)) {
					return 0;
				}
			}
		}
	}
	return 1;
}

int32_t main(void) {
	int32_t N, M, H;
	scanf("%d %d %d", &M, &N, &H);
	Graph g = {
		.visited = allocate_3rd_dimenstion(N, M, H),
		.dist = allocate_3rd_dimenstion(N, M, H),
		.max_ht = H,
		.max_col = M,
		.max_row = N,
	};

	input(N, M, H, g.visited);
	// print(N, M, H, g.dist);
	uint64_t path = BFS(g);
	// print(N, M, H, g.visited);
	is_no_zero(&g) == 0 ? printf("-1\n") : printf("%ld\n", path);

    return 0;
}
```

# 🎑 후기

함수 하나하나를 구현하는 것도 시간을 많이 잡아 먹었지만, 하나의 실수 때문에,
거의 한 시간을 잡아먹었습니다. 함수를 스니펫에 저장하고 쓰거나 아니면,
로직을 이해했으면, 앞으로는 라이브러리에서 제공해주는 걸 쓸 까 싶습니다.

그리고 포인터에 대한 이해도 좀 높여야 하고요.
