---
id: "1300"
aliases: []
tags: []
---

# 💳 문재이해

100,000 이하인 N 이 주어졌을 때, N x N 행열에서, 행열[i][j] = i x j를
만족하는 행렬이 있을 경우, 해당 행렬을 일차원 배열에 넣습니다.
해당 배열을 오르참순으로 정렬 하였을 때, k번 째 큰 수를 구하세요.
행렬과, 일차원 배열의 인덱스는 1부터 시작합니다.

# 🚥 문제접근

N x N은 32 bit 정수의 범위를 넘습니다. 따라서, N x N의 배열에 계산한
수를 저장하기 보다는 동적으로 구합니다.

<style>
    .multiple-grid {
        display: grid;
        padding: 10px;
        width: 265px;
        margin: 10px;
        background-color: #2196F3;
        grid-template-columns: repeat(8, 30px);
        grid-template-rows: repeat(8, 30px);
        border: 2px solid;
    }
    .multiple-box {
        text-align: center;
        color: #3F3F3F;
        border: 1px solid;
        background-color: #FFFFFF;
        opacity: 0.8;
    }

</style>
<div class="multiple-grid">
<div class="multiple-box">1</div>
<div class="multiple-box">2</div>
<div class="multiple-box">3</div>
<div class="multiple-box">4</div>
<div class="multiple-box">5</div>
<div class="multiple-box">6</div>
<div class="multiple-box">7</div>
<div class="multiple-box">8</div>
<div class="multiple-box">2</div>
<div class="multiple-box">4</div>
<div class="multiple-box">6</div>
<div class="multiple-box">8</div>
<div class="multiple-box">10</div>
<div class="multiple-box">12</div>
<div class="multiple-box">14</div>
<div class="multiple-box">16</div>
<div class="multiple-box">3</div>
<div class="multiple-box">6</div>
<div class="multiple-box">9</div>
<div class="multiple-box">12</div>
<div class="multiple-box">15</div>
<div class="multiple-box">18</div>
<div class="multiple-box">21</div>
<div class="multiple-box">24</div>
<div class="multiple-box">4</div>
<div class="multiple-box">8</div>
<div class="multiple-box">12</div>
<div class="multiple-box">16</div>
<div class="multiple-box">20</div>
<div class="multiple-box">24</div>
<div class="multiple-box">28</div>
<div class="multiple-box">32</div>
<div class="multiple-box">5</div>
<div class="multiple-box">10</div>
<div class="multiple-box">15</div>
<div class="multiple-box">20</div>
<div class="multiple-box">25</div>
<div class="multiple-box">30</div>
<div class="multiple-box">35</div>
<div class="multiple-box">40</div>
<div class="multiple-box">6</div>
<div class="multiple-box">12</div>
<div class="multiple-box">18</div>
<div class="multiple-box">24</div>
<div class="multiple-box">30</div>
<div class="multiple-box">36</div>
<div class="multiple-box">42</div>
<div class="multiple-box">48</div>
<div class="multiple-box">7</div>
<div class="multiple-box">14</div>
<div class="multiple-box">21</div>
<div class="multiple-box">28</div>
<div class="multiple-box">35</div>
<div class="multiple-box">42</div>
<div class="multiple-box">49</div>
<div class="multiple-box">56</div>
<div class="multiple-box">8</div>
<div class="multiple-box">16</div>
<div class="multiple-box">24</div>
<div class="multiple-box">32</div>
<div class="multiple-box">40</div>
<div class="multiple-box">48</div>
<div class="multiple-box">56</div>
<div class="multiple-box">64</div>
    
</div>

> "행렬을 참고해주세요."

K가 1이면 1을 반환하면 됩니다. 왜냐면, 1번 째로 가장 큰 수는 1입니다.

반대로 K가 N * N이면 N * N을 바환합니다. 왜냐하면, N * N 행렬에서 
가장 큰 값은 N * N, N이 8인 경우 64입니다.

이진 탐색을 할 경우 탐색 범위는 1부터 64입니다.

그러면 K번 째로 큰 수를 어떻게 찾을까요?

탐색 범위에 절반을 1부터 N까지 나누 수를 합한 값이 탐색 범위에 절반 값에 
l번째 큰 수입니다.

만약 l이 k보다 작으면 탐색 범위 시작을 절반 + 1을 할당해주고,
반대로 크면, 탐색 범위의 끝을 절반 - 1을 할당합니다.

...


***실패하였습니다.***

```
3 7
mid: 5, start: 1, end: 9, k_th: 6
mid: 7, start: 5, end: 9, k_th: 8
mid: 6, start: 5, end: 6, k_th: 8
```

위와 같이 절반 값인 6은 행렬 표에 의하면 8번째로 큰 수는 맞습니다.
하지만, 6은 7번째, 8번째로 큰 수 입니다. 이는 중복으로 n번째 수가 있기 때문에
k인 7이 8보다 작아서 결국엔 참색 탐색 범위가 5, 5가 될 것입니다.

그러므로 탐색 조건을 변경해야 합니다.

만약에 k 가 현재 k_th번째 보다 같거나 작을 때(k <= k_th) 마이너스 1을 
하는 것이 아니라 그냥 mid를 할당합니다.

끝나는 범위에 마이너스 1을 하는 것은 mid값을 탐색 범위에 포함시키지 않겠다는
뜻입니다. 허나 이번 탐색 범위에서는 mid값이 탐색 범위일 수 도 있으므로,
마이너스 1을 안 하는 것입니다.

반대로 시작 범위에 mid + 1값을 할당하는 이유는 k > k_th일 경우
mid값은 탐색 범위에서 벗어납니다. 이는 mid 값이 찾는 목표가 아니라는 것을
의미합니다. 그러므로 1을 더하여 더 큰 구간을 탐색합니다.

## 1️⃣  문제풀이

1. 몇번째로 큰 수인지 찾기
2. 이진탐색

### source code

```c
#include<stdio.h>
#include<stdint.h>


int32_t find_k_th(int64_t num, int32_t length) {

    int32_t count = 0;

    for (int32_t i = 1; i <= length; i += 1) {
        count += num / i;
    }
    
    return count;
}

int64_t binary_search(int32_t n, int32_t k) {
    int64_t start = 1;
    int64_t end = (int64_t)n * n;
    
    while (start != end) {
        int64_t mid = (start + end + 1) / 2;
        int32_t k_th = find_k_th(mid, n);

        if (k_th < k) {
            start = mid;
        } else (k_th > k) {
            end = mid - 1;
        } else {
            return mid;
        }
    }
}

int32_t main(void) {
    int32_t n, k;
    scanf("%d %d", &n, &k);
    int64_t k_th_num = binary_search(n, k);
    printf("%d\n", k_th_num);
    return 0;
}
```


