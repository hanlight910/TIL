---
id: "24445"
aliases: []
tags:
  - bfs
ref:
  - https://www.acmicpc.net/problem/24445
---

# ğŸ’³ ë¬¸ì œì´í•´

Nê°œì˜ ì •ì ê³¼ Mê°œì˜ ê°„ì„ ìœ¼ë¡œ êµ¬ì„±ëœ ë¬´ë°©í–¥ ê·¸ë˜í”„(undirected graph)ê°€ ì£¼ì–´ì§„ë‹¤. 
ì •ì  ë²ˆí˜¸ëŠ” 1ë²ˆë¶€í„° Në²ˆì´ê³  ëª¨ë“  ê°„ì„ ì˜ ê°€ì¤‘ì¹˜ëŠ” 1ì´ë‹¤. ì •ì  Rì—ì„œ
ì‹œì‘í•˜ì—¬ ë„ˆë¹„ ìš°ì„  íƒìƒ‰ì„ ë…¸ë“œë¥¼ ë°©ë¬´í•  ê²½ìš° 1ë¶€í„° Nì˜ ë…¸ë“œ ë°©ë¬¸ ìˆœì„œë¥¼
ì¶œë ¥í•˜ì‹œì˜¤. ì¸ì ‘ ì •ì ì€ ë‚´ë¦¼ì°¨ìˆœìœ¼ë¡œ ë°©ë¬¸í•©ë‹ˆë‹¤.

# ğŸš¥ ë¬¸ì œì ‘ê·¼

bfs ì½”ë“œ
```
bfs(V, E, R) {  # V : ì •ì  ì§‘í•©, E : ê°„ì„  ì§‘í•©, R : ì‹œì‘ ì •ì 
    for each v âˆˆ V - {R}
        visited[v] <- NO;
    visited[R] <- YES;  # ì‹œì‘ ì •ì  Rì„ ë°©ë¬¸ í–ˆë‹¤ê³  í‘œì‹œí•œë‹¤.
    enqueue(Q, R);  # í ë§¨ ë’¤ì— ì‹œì‘ ì •ì  Rì„ ì¶”ê°€í•œë‹¤.
    while (Q â‰  âˆ…) {
        u <- dequeue(Q);  # í ë§¨ ì•ìª½ì˜ ìš”ì†Œë¥¼ ì‚­ì œí•œë‹¤.
        for each v âˆˆ E(u)  # E(u) : ì •ì  uì˜ ì¸ì ‘ ì •ì  ì§‘í•©.(ì •ì  ë²ˆí˜¸ë¥¼ ë‚´ë¦¼ì°¨ìˆœìœ¼ë¡œ ë°©ë¬¸í•œë‹¤)
            if (visited[v] = NO) then {
                visited[v] <- YES;  # ì •ì  vë¥¼ ë°©ë¬¸ í–ˆë‹¤ê³  í‘œì‹œí•œë‹¤.
                enqueue(Q, v);  # í ë§¨ ë’¤ì— ì •ì  vë¥¼ ì¶”ê°€í•œë‹¤.
            }
    }
}
```

bfs ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•˜ì—¬ ì£¼ì–´ì§„ ë…¸ë“œë“¤ì„ íƒìƒ‰í•©ë‹ˆë‹¤.

## ğŸ› ï¸ í’€ì´

ì°¸ê³ : [24444](06-DAILY/TIL/algorithm/24444.md)

ì¸ì ‘ ì •ì ë“¤ì„ ë‚´ë¦¼ì°¨ìˆœìœ¼ë¡œ ì •ë ¬

### ğŸ–¥ï¸ source code

```c
#include<stdio.h>
#include<stdint.h>
#include<stdlib.h>

typedef struct queue {
    int32_t data;
    struct queue* next;
    struct queue* first;
} queue;

typedef struct {	
	int32_t** graph;
	int32_t* visited;
	int32_t* order;
	int32_t* neighbors;
	int32_t* N;
} Graph;

int32_t dequeue(queue* a) {
    if((*a).first != NULL) {
        queue* temp = a->first; 
		(*a).first = (*a).first->next;
		int32_t val = temp->data;
		free(temp);
		return val;
    }
    return 0;
}

void enqueue(queue** a, int32_t val) {
    if (*a == NULL || (*a)->first == NULL) {
		*a = (queue*)malloc(1 * sizeof(queue));
        (*a)->first = *a;
        (*a)->next = NULL;
        (*a)->data = val;
    } else {
        queue *b = (queue*)malloc(sizeof(queue) * 1);
		(*b).data = val;
		(*b).next = NULL;
		(*b).first = (*a)->first;
        (*a)->next = b;
		(*a) = b;
    }
    return;
}

int32_t peek(queue* a) {
    if (a->first == NULL) {
		printf("null: ");
        return 0;
    }
    return a->data;
}

int32_t empty(queue* a) {
	if (a->first == NULL) {
		return 1;
	}
	return 0;
}

int32_t compare(const void* a, const void* b) {
	return *(int32_t*)b - *(int32_t*)a;
}

int32_t dfs(Graph a, int32_t R) {
	queue* q = NULL;
	int32_t count = 1;
	enqueue(&q, R);

	for (int32_t i = 1; i <= *a.N; i += 1) {
		if (a.graph[i] != NULL) {
			qsort(a.graph[i], a.neighbors[i], sizeof(int32_t), compare);
		}
	}
	a.visited[R] = 1;

	while (!empty(q)) {
		int32_t num = dequeue(q);
		a.order[num] = count++;

		for (int32_t i = 0; i < a.neighbors[num]; i += 1) {
			if (!a.visited[a.graph[num][i]]) {
				a.visited[a.graph[num][i]] = 1;
				enqueue(&q, a.graph[num][i]);
			}
		}
	}

	return 0;
}

int32_t main(void) {
	int32_t N, M, R;
	scanf("%d %d %d", &N, &M, &R);
	Graph a = {
		.order = (int32_t*)calloc((N + 1), sizeof(int32_t)),
		.graph = (int32_t**)malloc((N + 1) * sizeof(int32_t*)),
		.visited = (int32_t*)calloc((N + 1), sizeof(int32_t)),
		.N = &N,
		.neighbors = (int32_t*)calloc((N + 1), sizeof(int32_t)),
	};

	for (int32_t i = 0; i < M; i += 1) {
		int32_t u, v;
		scanf("%d %d", &u, &v);
		a.graph[u] = (int32_t*)realloc(a.graph[u], (a.neighbors[u] + 1) * sizeof(int32_t));
		a.graph[v] = (int32_t*)realloc(a.graph[v], (a.neighbors[v] + 1) * sizeof(int32_t));

		a.graph[u][a.neighbors[u]++] = v;
		a.graph[v][a.neighbors[v]++] = u;
	}

	dfs(a, R);
	for (int32_t i = 1; i <= N; i += 1) {
		printf("%d\n", a.order[i]);
	}
    return 0;
}
```

