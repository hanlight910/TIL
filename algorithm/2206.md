---
id: "2206"
aliases: []
tags: []
---

# 💳 문제이해

N x M 행렬이 주어집니다. 1과 0으로만 구성되어 있습니다. 0은 빈공간을,
1은 벽을 의미합니다. 사용자가 위치 (1, 1)에서 시작합니다. 벽은 
한 번만 부수고 지나갈 수 있습니다. 사용자가 이동할 수 있는 방향은
좌우, 상하입니다. (N, M)에 도착하는데 필요한 최단 경로를 구하시오.
도착하지 못하면 -1를 출력하시오.

# 🚥 문제접근

전형적인 미로 탈출 문제 같지만, 벽을 깰 수 있는 조건이 있습니다.
한 번 뿐이지만, 이 부분을 유의해야 합니다.

## 🌏 분석

### ☔ BFS

너비를 우선적으로 탐색하는 알고리즘입니다. 가중치가 서로 동일할 경우,
최단 경로를 구하는 방법으로 적절합니다.

벽을 부순다는 조건이 걸립니다. 벽을 부수는 경우를 추가하게 되면,
단계를 넓힐 때마다, 어떤 정점에서는 벽을 부수지 않고, 어떤 정점에서는
벽을 부셔야만 더 빠른 경로를 탐색할 수 있을지 모릅니다. 즉 벽을 
부순다는 조건이 영향을 크게 끼치지 않을지 유의해야 합니다.

동적 프로그래밍으로 벽을 부수지 않는 선택보다 벽을 부수는 선택이 더 경로가
짧은지 생각해야 할 필요성이 있는 것 같습니다.

이를 위해 벽을 한 번 부순 경우와, 부수지 않고 방문한 경우를 두 개로 
나누어서 관리합니다.

벽에 도착한 지점에서는 해당 원소가 벽을 이미 부셨는지 확인합니다.
그러하지 않으면 벽을 부수고 이동합니다.

벽이 아닌 이동이 가능한 칸에서는 우선 해당 칸에 방문을 하였는지 
확인합니다. 그리고 벽을 부수었으면, 업데이트 합니다.

... 문제가 있습니다. 올바른 벽을 부수지 않으면 목적지에 도달할 수 없습니다.
무조건 부수는게 아니라 부수기 전에 부순 후에 목적지에 도착할 수 있는지에
대한 여부를 파악해 합니다.

그렇다는 건 벽을 발견하였을 때 벽을 부수었구나, 부수지 않는 경우를
사전 탐색을 할 필요성이 생깁니다. 근데 아무리 생각해도 위에 방식을 사용한다는 
것은 사실상 모든 원소에 `DFS`를 실행한다는 소리와 유사한 이야기입니다.

정답 코드를 본 결과, 시작 지점부터 모든 벽 사이의 최단 거리를 저장하고,
목표 지점부터 모든 벽 사이의 최단 거리를 저장하고, 어떤 벽의 두 최단 
거리를 저장합니다. 그러면 그 벽의 두 개의 최단 거리를 더하고, 벽을 부순 경우인
1을 더해주면 해당 경로는 그 벽을 부순 경우의 최단 거리입니다.

추가적으로 벽이 없는 경우도 처리해야 합니다.

#### 🖥️ source code

```c
#include<stdio.h>
#include<stdint.h>
#include<stdlib.h>

#define DIRECTIONS { { 0, -1 }, {0, 1}, { -1, 0 }, { 1, 0 } }
#define DEFINE_DATA(tmp, r, c) Data tmp = { (r), (c) };
#define ALLOCATE_UINT32_T(N) (uint32_t**)malloc(N * sizeof(uint32_t*))
#define GET_VAL(dist, data) dist[data.row][data.col]
#define MIN(a, b) a > b ? b : a
#define PRINT(g, cur_d) printf("row: %d; col: %d; is_b: %d\n", cur_d.row, cur_d.col, g.visited[cur_d.row][cur_d.col]);

typedef struct Data {
    int32_t row;
    int32_t col;
} Data;

// // record visited through breaking wall or not
// typedef struct Wall {
// 	_Bool b; // breakthrouh;
// 	_Bool not_b; //not break through
// } Wall;

typedef struct Graph {
    uint32_t **graph;
	uint32_t **visited;
    uint32_t **dist;
    uint32_t max_r;
    uint32_t max_c;
} Graph;

typedef struct Node {
    Data val;
    struct Node* next;
    struct Node* head;
} queue;

queue* enqueue (queue* q, Data val) {
    queue* new_q = (queue*)malloc(sizeof(queue));
    new_q->next = NULL;
    new_q->val = val;
    if (q == NULL) {
        new_q->head = new_q;;
    } else {
        new_q->head = q->head;
        q->next = new_q;
    }
    return new_q;
}

Data dequeue(queue** q) {
    Data val;
    if (*q != NULL) {
        val = (**q).head->val;
        queue* tmp = (**q).head;
        if ((**q).head->next == NULL) {
            (*q) = NULL;
        } else {
            (**q).head = (**q).head->next;
        }

        free(tmp);
    }
    return val;
}

uint8_t is_valid(Graph* g, Data v, Data prev) {
    if (g->max_r > v.row && v.row >= 0 &&
        (g->max_c > v.col && v.col >= 0)) {
        if (!g->graph[v.row][v.col] && !g->visited[v.row][v.col]) {
			return 1;
		}
    }
    return 0;
}

void print(uint32_t** dist, int32_t N, int32_t M) {
	for (int i = 0; i < N; i += 1) {
		for (int32_t j = 0; j < M; j += 1) {
			printf("%2d ", dist[i][j]);
		}
		printf("\n");
	}
}

int32_t BFS(Graph g, Data start) {
	// print(g);
    queue* q = NULL;
    int32_t directions[4][2] = DIRECTIONS;

	DEFINE_DATA(data, start.row, start.col);
    q = enqueue(q, data);
    g.visited[start.row][start.col] = 1;
	g.dist[start.row][start.col] = 1;

    while (q != NULL) {
        Data cur_v = dequeue(&q);

		// printf("dice: %d, %d\n", cur_v.row, cur_v.col);
        for (int i = 0; i < 4; i += 1) {
			DEFINE_DATA(cur_d, ((int32_t)cur_v.row + directions[i][0]), ((int32_t)cur_v.col + 
						directions[i][1]));
			uint8_t valid = is_valid(&g, cur_d, cur_v);
			
			if (valid == 1) {
				g.visited[cur_d.row][cur_d.col] = 1;
				q = enqueue(q, cur_d);	
				// PRINT((g), cur_d);
				g.dist[cur_d.row][cur_d.col] = g.dist[cur_v.row][cur_v.col] + 1;
				
			}
			// } else if (valid == 2) { // 벽이 없음과 동시에 방문하지 않은 경우
			// 	// printf("row: %d; col: %d; is_b: %d\n", cur_d.row, cur_d.col, g.visited[cur_d.row][cur_d.col].b);
			// 	g.visited[cur_d.row][cur_d.col]= 1;	
			// 	if (g.visited[cur_v.row][cur_v.col]) {
			// 		g.visited[cur_d.row][cur_d.col] = 1;
			// 	}
			// 	q = enqueue(q, cur_d);
			// 	g.dist[cur_d.row][cur_d.col] = g.dist[cur_v.row][cur_v.col] + 1;
			// }
        }
    }
	return g.dist[g.max_r - 1][g.max_c - 1];
}

uint32_t** allocate_first(uint32_t** arr, int32_t N, int32_t M) {
	arr = (uint32_t**)malloc(N * sizeof(uint32_t*));
	for (int32_t i = 0; i < N; i += 1) {
		*(arr + i) = (uint32_t*)calloc(M, sizeof(uint32_t));
	}
	return arr;
}

int32_t get_min(Graph* g1, Graph* g2, int32_t N, int32_t M) {
	int32_t min_val = N * M;
	int32_t directions[4][2] = DIRECTIONS;
	_Bool no_wall = 1;
	for (int32_t i = 0; i < N; i += 1) {
		for (int32_t j = 0; j < M; j += 1) {
			int32_t min_g1 = N * M;
			int32_t min_g2 = N * M;
			if (g1->graph[i][j] == 1) {
				no_wall = 0;
				for (int32_t k = 0; k < 4; k += 1) {
					DEFINE_DATA(cur, (i + directions[k][0]), (j + directions[k][1]));
					if (0 <= cur.row && cur.row < N && (0 <= cur.col && cur.col < M)) {
						if (GET_VAL(g1->dist, cur)) {
							min_g1 = MIN(min_g1, GET_VAL(g1->dist, cur));	
						}

						if (GET_VAL(g2->dist, cur)) {
							min_g2 = MIN(min_g2, GET_VAL(g2->dist, cur));

						}
					}
				}
				min_val = MIN(min_val, (min_g1 + min_g2 + 1));
			}	
		}
	}
	if (no_wall) {
		return g1->dist[N - 1][M - 1];		
	}
	return min_val < (N * M) ? min_val : -1;
}

int32_t main(void) {
	int32_t N, M;
	scanf("%d %d", &N, &M);

	Graph g = {
		.visited = (uint32_t**)malloc(N * sizeof(uint32_t*)),
		.graph = (uint32_t**)malloc(N * sizeof(uint32_t*)),
		.dist = (uint32_t**)malloc(N * sizeof(uint32_t*)),
		.max_r = N,
		.max_c = M,
	};

	for (int i = 0; i < N; i += 1) {
		g.visited[i] = (uint32_t*)calloc(M, sizeof(uint32_t));
		g.dist[i] = (uint32_t* )calloc(M, sizeof(uint32_t));
		g.graph[i] = (uint32_t* )calloc(M, sizeof(uint32_t));
		char str[1001];
		scanf("%s", str);

		for (int32_t j = 0; j < M; j += 1) {
			g.graph[i][j] = str[j] - 48;
			g.visited[i][j] = 0;
			g.visited[i][j] = 0;
		}
	}

	Graph g1 = {
		.graph = g.graph,
		.max_r = N,
		.max_c = M,
	};

	g1.visited = allocate_first(g1.visited, N, M);
	g1.dist = allocate_first(g1.dist, N, M);

	DEFINE_DATA(zero, 0, 0);
	int32_t path = BFS(g, zero);
	DEFINE_DATA(end, (N - 1), (M - 1));
	int32_t path1 = BFS(g1, end);
	// print(g.dist, N, M);
	// printf("\n");
	// print(g1.dist, N, M);
	int32_t min = get_min(&g, &g1, N, M);
	printf("%d\n", min);
	// if (path == 0) {
	// 	printf("%d\n", -1);
	// } else {
	// 	printf("%d\n", path);
	// }
    
    return 0;
}
```
## 🎑 후기

정답 코드를 보았음에도 불구하고 3시간이 걸린 문제, 저의 가독성이 떨어지는
코드를 수정하는데에 시간이 많이 걸렸습니다. 다음부터는 객체 지향을
지원하는 `c++`를 사용할 것 같습니다.

> 소스 코드는 효율적으로 작성된 코드가 아닙니다.
