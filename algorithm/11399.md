---
id: "11399"
aliases: []
tags: []
---

# Reflections

## 💳 문제이해

N개의 수열이 주어졌을 때, 해당 수열에서 각각의 원소에 누적합계를 더하여
최소한의 합을 구하세요.

## 🚥 문제접근

주어진 수열에서 최소한의 누적합을 구하려면, 수열을 오름차순으로 정렬하는 것이
최선입니다.

수열을 오름차순으로 정렬하면, 앞에 위치한 값이 상대적으로 작은 값이 됩니다. 
각 원소의 누적 합이 계산될 때, 작은 값이 반복적으로 더해지기 때문에 누적 합이 
최소화됩니다.

### 1️⃣  문제풀이

주어진 수열을 오름차순으로 정렬,
누적 합 계산

#### source code

```c
#include<stdio.h>
#include<stdint.h>

void merge(int32_t list[], int32_t sorted[], int32_t left, int32_t right, int32_t mid) { 
	int left_index = left;
    int mid_index = mid + 1;
    int list_left_index = left;

    for (; list_left_index <= mid && mid_index <= right; left_index += 1) {
        if (list[list_left_index] <= list[mid_index]) {
            sorted[left_index] = list[list_left_index];
            list_left_index += 1;
        } else {
            sorted[left_index] = list[mid_index];
            mid_index += 1;
        }
    }

    if (list_left_index > mid) {
        for (int32_t i = mid_index; i <= right; i += 1, left_index += 1) {
            sorted[left_index] = list[i];
        }
    } else {
        for (int32_t i = list_left_index; i <= mid; i += 1, left_index += 1) {
            sorted[left_index] = list[i];
        }
    }

    for (int32_t i = left; i <= right; i += 1) {
        list[i] = sorted[i];
    }

    return;
}

void merge_sort(int32_t sequence[], int32_t sorted[], int32_t left, int32_t right) {
    if (left < right) {
        int32_t mid = (left + right) / 2;
        merge_sort(sequence, sorted, left, mid);
        merge_sort(sequence, sorted, mid + 1, right);
        merge(sequence, sorted, left, right, mid);
    }

    return;
}

int32_t main(void) {
    int32_t N;
    scanf("%d", &N);

    int32_t sequence[N];

    for (int32_t i = 0; i < N; i += 1) {
        scanf("%d", &sequence[i]);
    }
    int32_t sorted[N];
    merge_sort(sequence, sorted, 0, N - 1);

    return 0;
}
```
