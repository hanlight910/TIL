---
id: "2559"
aliases: []
tags: []
---

# Reflection

## 💳 문제이해

정수 (-100 <= number <= 100) 담긴 수열이 주어졌을 때, 특정 길이 K만큼의 연속된 부분 
수열의 합 중에서 가장 큰 값을 찾으세요.

## 🚥 문제접근

루프를 사용하여 각 수열을 순회하여, 구간 별로 더하는 방법이 있지만, 해당 방법은
루프 안에 루프를 사용하여 시간복잡도 $O(n x k)$ 비효휼, 느립니다.

대신 동적 프로그래밍을 사용하여 각 구간 합을 미리 구하여 저장한 배열을 만들어
이를 활용해 원하는 구간의 합을, 시간복잡도 $O(n)으로, 빠르게 해결할 수 있습니다.

### 1️⃣  문제풀이

수열이 주어졌을 때,

```
10 5
3 -2 -4 -9 0 3 7 13 8 -3
```
#### 1. 1부터 시작하여 구간별 원소 값 합계 구하기

각 원소를 순회하여, 첫번째 원소부터 각 인덱스 원소에 합계를 배열에다 저장합니다.

공식은 현재 원소의 값을 전 원소의 합계와 더하면 됩니다.

$$ 현재 원소 합계 = 현재 원소 값 + 전 원소의 합계 $$

첫번째 원소는 그냥 저장해줍니다.
- sum_array[1] = 3;

이제 두번째 원소부터 위에 공식을 적용해줍닏다.
- sum_array[2] = -2 + sum_array[1];
- sum_arrya[3] = -4 + sum_array[2];

#### 2. K번 연속 구간 합계 구하기

이제 주어진 수열의 각 원소를 순회하면서 K번 연속 구간을 더하면 되는데요.

현재 원소 기준 K번 다음 원소의 최대 합계를 현재 원소 기준, 전 원소의 합계를 빼면 됩니다.

**공식**:
$$ K번째 연속 합계 = K번째 합계 - 전\  원소의 합계 $$

- 다만 주의해야 할 건, 현재 원소 기준 K번째 뒤라는 건, 만약에 K가 5고 지금 단계가 7(뒤에서 4번째)번째라면,
5번째 뒤에 원소가 없으므로 계산이 끝나야 합니다.

#### 🖥️ 소스 코드
```c
#include<stdio.h>
#include<stdlib.h>
#include<stdint.h>

int32_t* get_prefix_sum(int32_t length, int32_t sequence[]) {
    int32_t* return_value = NULL;

    int32_t* sum_sequence = (int32_t*)malloc(length * sizeof(int32_t));

    sum_sequence[0] = sequence[0];
    for (int32_t i = 1; i < length; i += 1) {
        sum_sequence[i] = sequence[i] + sum_sequence[i - 1];
    }

    return_value = sum_sequence;

    return return_value;
}

int32_t print_max_sum_of_K_row(int32_t length, int32_t K, int32_t sum_sequence[]) {
    int32_t return_value = 0;

    int32_t max_value = sum_sequence[0 + k - 1];
    for (int32_t i = 1; i < length - K + 1; i += 1) {
        int32_t current_value = sum_sequence[i + k - 1] - sum_sequence[i - 1];

        if (current_value > max_value) {
            max_value = current_value;
        }
    }
    printf("%d\n", max_value);

    return 0;
}
```

> [11659/구간합](06-DAILY/TIL/algorithm/11659.md) 같은 원리의 구간합 문제입니다.

## ref
- [백준/2559](https://www.acmicpc.net/problem/2559)
