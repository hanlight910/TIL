---
id: "11049"
aliases: []
tags: []
---

# 💳 문제이해

N개의 행열의 크기 주어졌을 때, 각 행열의 곲한 횟수는 N x M x K이다. 주어진 행열의
크기에서 곱하고 모두 합하였을 때 최소 값이 나올 수 있도록 곱하는 순서를 변경하세요.

다는 행렬의 순서는 변경 할 수 없습니다.

# 🚥 문제접근

```
5 4
4 2 
2 8
```

이렇게 주어졌을 때, (AB)C 를 할 것이냐, A(BC) 아니면 이렇게 연산할 것이냐,
이 두가지 경우밖에 없습니다.

- (A x B) x C: (5 x 4 x 2) + (5 x 2 x 8) = 120
- A x (B x C): (4 x 2 x 8) + (5 x 4 x 8) = 224

도출 한 결과 (A x B) x C가 가장 적게 곱하기 횟수를 가집니다. 


### Matrix Chain Multiplication(행렬 연쇄 곱셈)

가령 행렬 $A_1 ~ A_i$ 가 있다고 합니다.
모두 하나하나 비교해서 탐색하면 매우 시간이 오래 걸릴 것입니다.

그러니 각 구간의 최소 곱한 횟수를 저장하여, 결과적으로 각 구간의 최소 
합을 더합니다.

$$(A_{i...k})(A_{k+1 ...j})$$

이런 식으로 각 구간마다 최소 횟수를 구합니다.

i를 시작 위치, j를 끝나는 위치로 해서 1부터 시작하여 n - 1을 계산합니다.

행렬 두 개의 곱한 횟수를 구할려면 최소 두개 이상이 필요합니다.
따라서 i는 1번째로 시작하지만, j는 무조건적으로 i 보다 커야 합니다.

- $A_1 \rightarrow A_2$
- 4 x 3 $\rightarrow$ 3 x 5
- i $\rightarrow j$

이제 위와 같은 로직을 각 구간(index i)마다 실행할 때, j를 점차 늘리면서
구간을 넓힙니다.

[i, j]
1. 1는 [1, 2], [1, 3], [1, 4]
2. 2는 [2, 3], [2, 4]
3. 3은 [3, 4]

각 구간의 최소 곱셈 횟수는 1, 4에 저장 되어 있습니다.

위와 같이 구간을 넓히면서 어떻게 최소 곱셈 횟수를 구할 까요?

$$(A_{i...k})(A_{k+1 ...j})$$

결국엔 위와 같은 공식을 따르게 됩니다.

k는 i부터 k까지의 곱셈 최소 합이며, 다른 쪽은 k + 1부터 j까지의 최소 곱셈
횟수의 합입니다.

즉 k는 i 와 j 사이의 길이를 의미합니다.

예를 들어, 행렬이 2개일 때는
3 x 4 와  4 x 5를 곱했을 때, 둘의 최소 곱셈 합은 3 x 4 x 5 입니다.
그러면 만약 행렬이 3개일 때는 

```
3 x 4
4 x 5
5 x 6
```
($A_1 \times A_2) \times A_3$
와
$A_1 \times (A_2 \times A_3)$ 두 개의 경우에서 최소값을 구해야 합니다.

$$min(M[i, j] = M[i, k] + M[k + 1, j] + p_{i - 1}p_kp_j)$$

위의 공식을 따릅니다.

1. M[i, k]는 위에 언급했듯이 i는 첫 번째 원소를 나타태며, k는 k번째 원소를 나타냅니다.
즉 i 부터 k까지의 최소 곱셈 횟수의 합을 나타냅니다.

2. M[k + 1, j]는 1번 사항에 반대 절반인 k + 1부터 j 까지의 최소 곱셈 횟수의 합을
나타냅니다.

3. $p_{i - 1}p_kp_j$는 i번째 행과 곱하기 k번째 행 곱하기 j번째 열을 의미합니다.

- [3, 4], [4, 5], [5, 6]
- $[p_0, p_1], [p_1, p_2], [p_2, p_3]$

이처럼 k는 i번째로 시작해서 j - 1까지 순회합니다.

i 가 1이면 k는 1부터 시작합니다.
1. i 부터 k의 값은 행렬 본인 값이기 때문에 0입니다.
2. k + 1부터 j의 값은 4 x 5 x 6입니다.
    - 120이 나옵니다.
3. 3 x 4 x 6을 구합니다. 
    - 72

4. 다 합합니다. 0 + 120 + 72 = 192

k는 k는 j까지 k를 더하면서 위에 로직을 반복합니다.

위에 공식에 따라
1. M[i, k]는 M[1, 2] 1부터 k까지의 값을 가져옵니다.
    - 이미 저장 되어 있는 (3 x 4 x 5)의 값을 가져옵니다.    
    - 60

2. M[k + 1, j] = M[3, 3]는 본인 행렬이기 때문에 0입니다.

3. $p_(i - 1)p_kp_j$ 3 x 5 x 6 = 90입니다.
4. 이제 전부 더합니다.
    - 60 + 0 + 90 = 150입니다.

$(A_1 \times A_2) \times A3$ 인 150이
$A_1 times (A_2 \times A_3)$ 인 192 보다 작습니다.
고로 150을 M[1, 3]까지의 구간에 저장합니다.

위에 과정을 i를 1식 추가하면서, j까지 실행합니다.

## 💡 문제풀이

### source code

```c
#include<stdio.h>
#include<stdint.h>
#include<stdlib.h>

#define min(a, b)(a > b ? b : a)

void input_matrix_arr(int32_t* matrix_arr[], int32_t length) {
    for (int32_t i = 0; i < length; i += 1) {
		matrix_arr[i] = (int32_t*)malloc(2 * sizeof(int32_t));
        scanf("%d %d", &matrix_arr[i][0], &matrix_arr[i][1]);
    }
    return;
}

int32_t get_min_matrix_chain_multiplication(int32_t* matrix_arr[], int32_t length) {
    int32_t dp[length][length];
    if (length == 1) {
        return 0;
    }

    for (int i = 0; i < length; i += 1) {
        for (int j = 0; j < length; j += 1) {
            dp[i][j] = 0; 
        }
    }

    for (int32_t temp_length = 1; temp_length <= length; temp_length += 1) {
        for (int32_t i = 0; i + temp_length < length; i += 1) {
            int32_t j = temp_length + i;
            dp[i][j] = 0x7FFFFFFE;
            for (int32_t k = i; k < j; k += 1) {
                int32_t a = dp[i][j];
                int32_t b = dp[i][k] + dp[k + 1][j] + (matrix_arr[i][0] * matrix_arr[k][1] * matrix_arr[j][1]);
                dp[i][j] = min(a, b);
            }
        }
    }
    
    return dp[0][length - 1]; 
}
int32_t main(void) {
    int32_t length;
    scanf("%d", &length);
    int32_t* matrix_arr[length];
    input_matrix_arr(matrix_arr, length);
    int32_t min_count = get_min_matrix_chain_multiplication(matrix_arr, length);
	printf("%d\n", min_count);
    return 0;
}
```
