---
id: "2630"
aliases: []
tags: []
---

# 💳 문제이해

N/N 사이즈를 가진 햐얀색 혹은 파란색 정사각형들로 이루어진 N x N 정사각형이
주어졌을 때, 해당 정사각형 칸이 하나의 색으로 될 때까지 정사각형 사이즈를 줄여
, 파란색과, 하얀색의 최대 크기의 정사각형 개수를 구하세요.

# 🚥 문제접근

정사각형에서 각 부분별로 탐색, 왼쪽 상단, 오른쪽 상단, 오른쪽 하단.
을 재귀적으로 탐색하여 결국엔 정사각형이 하나가 될 때까지 탐색

이렇게 각기 문제들을 분할하여 탐색하는 방법을 분할 탐색이라고 합니다.

## 1️⃣  문제풀이
- 왼쪽 상단, 오른쪽 상단, 왼쪽 하단, 오른쪽 하단 별로 N/2 * N/2 정사각형을 탐색
- 정사각형이 1이 되거나, 부분 정사각형이 하나의 색상으로 통일 될 때까지 계속합니다.

```c
#include<stdio.h>
#include<stdint.h>

void input_square(int32_t** square, int32_t length) {
    for (int32_t i = 0; i < length; i += 1) {
        for (int32_t j = 0; j < length; j += 1) {
            scanf("%d", &square[i][j]);
        }
    }

    return;
}

int32_t* get_number_colors(const int32_t** square, int32_t x, int32_t y,
int32_t N, int32* black_count, int32_t* white_count) { 
    int32_t temp_black_count

    for (int32_t i = 0; i < N; i += 1) {
        for (int32_t j = 0; j < N; j += 1) {
            if (square[i][j] == 1) {
                temp_black_count = 0;
            } 
        }
    }

    if (temp_black_count == N * N) {
        *black_count += 1;
    } else if (temp_black_count == 0) {
        *white_count += 1;
    } else {
        get_number_colors(x, y, N / 2, black_count, white_count);
        get_number_colors(x, y + N / 2, N / 2, black_count, white_count);
        get_number_colors(x + N / 2, y, N / 2, black_count, white_count);
        get_number_colors(x + N / 2, y + N / 2 , N / 2, black_count, white_count);
    }

    return 0;
    
}
int32_t main(void) {
    int32_t N;
    scanf("%d", &N);

    int32_t square[N][N];
    input_square(square, N);
    int32_t white_count = 0;
    int32_t black_count = 0;

    get_number_colors(0, 0, N, &black_count, &white_count);
    printf("%d\n%d\n", white_count, black_count);
    return;
}
```
