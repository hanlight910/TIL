---
id: "7579"
aliases: []
tags: []
---

# 💳 문제이해

N개의 앱의 사용 메모리와, 해당 앱을 비활성하기 위해 필요한 메모리가 주어졌을 때,

메모리 M 이상을확보 할려면, 비활성이 필요한 최소 메모리를 확보합니다.
최소 메모리를 구하시오.

# 🚥 문제접근

N이 5라고 가정, 
M이 7일 때

```
3 1 2 3 4
3 0 3 5 4
```

첫 째 줄에는 앱 당 사용중인 메모리가 주어지고, 둘 째 줄에는 비활성 하기 필요한
메모리가 주어집니다.

## ❓ 생각

감이 안 잡히므로, gpt한테 물업 보았습니다.

해당 문제는 **부분 배낭 문제(Knapsack Problem)**와 유사한 동전 계획법(DP)를
사용하여 해결 할 수 있다고 합니다.

전에 백준에서 풀었던 문제가 생각나서, 가져왔습니다.

### 💰 knapsack(부분 배낭)

해당 문제는 1 부터 특정 배낭 무게를 넘지 않는 선에서 최대한 많이 가치가 담긴
배낭을 가져가는 문제입니다.

dp배열을 사용하여 1 부터 특정 무게까지 각 무게에서 최대로 넣을 수 있는 가치를 
저장합니다.

현재 무게가 5라고 하면, 현재 가방의 무게를 더했을 때, 특정 가방 무게를 넘지
않으면, 현재 가방 가치 + 무게 4의 최대 가치를 더하고 저장하는 방법도 좋지만,

dp 특성상 1 부터 특정 무게까지의 가치를 저장하고 있습니다.
이는 현재 가방 무게에서, 무게 4를 뺀 값에 저장되어 있는 가치가 있다면,
이는 현재 가방 무게를 감당할 수 있다는 것을 의미합니다. 다만, 
뺀 값이 마이너스이면 감당이 안 되기 때문에, 그냥 넘어갑니다.
하지만 마이너스가 아니면, 뺀 값에 저장되어 있는 최대 가치를 현재 가방
무게와 더한 값을 무게 4에 저장되어 있는는 가치와 비교하여 더 큰 값을 할당합니다.

<p style="text-align: center;">dp배열[현재 가방][현재 무게] 
= max(dp[이전 가방][현재 무게], dp[현재 가방][현재 무게 - 현재 가방 무게] + 
현재 가방 가치)</p>


## 💡 문제풀이

knapback 처럼, 배낭의 무게는 메모리 사용, 배낭의 가치는 비활성 메모리
메모리 사용이 M에 도달 했을 경우입니다.

다만 종료 조건은 배낭 문제와는 다르게, 목표 값을 초과하는 게 아니라,
목표 이상이였을 때 필요한 비활성 메모리를 구하는 것입니다.

그러면, 이 문제는 사용 메모리를 기준으로 하는게 아니라, 비활성 메모리를 
기준으로 탐색해야 합니다. 즉 0부터 비활성 메모리에 합까지, 사용한 메모리의
최대 값을 저장합니다.

```
3 1 2 3 4
2 0 2 4 3
```

**공식:**

<p style="text-align: center;">dp배열[i][j] = max(dp배열[i - 1][j], 
dp배열[i][j - 비활성메모리[i]] + 사용메모리[i]);

y - 사용 메모리 | x - 비활성 메모리 |  | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11
:---:| :---:| :---:| :---:| :---:| :---:| :---:| :---:| :---:| :---:| :---:| :---:| :---:| :---:|:---:|
3 | 3                           | 0 | 0 | 0 | 0 | 3 | 3 | 3 | 3 | 3 | 3 | 3 | 3  | 3
1 | 0                           | 1 | 1 | 1 | 1 | 4 | 4 | 4 | 4 | 4 | 4 | 4 | 4  | 4
2 | 3                           | 2 | 1 | 1 | 1 | 4 | 4 | 4 | 6 | 6 | 6 | 6 | 6  | 6
3 | 5                           | 3 | 1 | 1 | 1 | 4 | 4 | 4 | 6 | 6 | 7 | 7 | 7  | 7
4 | 4                           | 4 | 1 | 1 | 1 | 4 | 5 | 5 | 5 | 8 | 8 | 9 | 9  | 9

위에 표처럼 만들면 된다. 

목표가 4 메모리면, 3이 최소 비활성 메모리인 것이다.

### 🖥️ source code

```c
#include<stdio.h>
#include<stdint.h>

#define max(a, b)(a > b ? a : b)

typedef struct {
    int32_t used_memory;
    int32_t disable_memory;
} Memory;

int32_t input(int32_t length, Memory* a) {
    for (int32_t i = 0; i < length; i += 1) {
        scanf("%d", &((*(a + i)).used_memory));
    }
    for (int32_t i = 0; i < length; i += 1) {
        scanf("%d", &a[i].disable_memory);
    }
    return 0;
}

int32_t min_disable_memory(int32_t length, int32_t target, const Memory* a) {

	int32_t sum = 0;
	for (int i = 0; i < length; i += 1) {
		sum += (a + i)->disable_memory;
	}

    int32_t dp[length + 1][sum + 1];
    for (int i = 0; i <= length; i += 1) {
        for (int j = 0; j <= sum; j += 1) {
            dp[i][j] = 0;
        }
    }

    for (int i = 1; i <= length; i += 1) {
        int32_t disable_memory = (*(a + i - 1)).disable_memory;
        int32_t used_memory = a[i - 1].used_memory;
        for (int j = 0; j <= sum; j += 1) {
            if (j - disable_memory >= 0)  {
                dp[i][j] = max(dp[i - 1][j], (dp[i - 1][j - disable_memory] + used_memory));
            } else {
                dp[i][j] = dp[i - 1][j];
            }
        }
    }

    int32_t return_value = 0;
    for (int32_t i = 0; i <= sum; i += 1) {
        if (target <= dp[length][i]) {
            return_value = i;
            break;
        }
    }

	// for (int i = 0; i < length + 1; i += 1) {
	// 	for (int j = 0; j < sum + 1; j += 1) {
	// 		printf("%d ", dp[i][j]);	
	// 	}
	// 	printf("\n");
	// }

    return return_value;
}
int32_t main(void) {
    int32_t n, target;
    scanf("%d %d", &n, &target);

    Memory a[n]; 

    input(n, a);
    int32_t min = min_disable_memory(n, target, a);
    printf("%d\n", min);

    return 0;
}
```
