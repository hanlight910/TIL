---
id: "2606"
aliases: []
tags: []
---

# 💳 문제이해

N개의 서로 네트워크를 통해 연결 컴퓨터가 주어지고, M개의
서로 연결된 컴퓨터들이 쌍으로 주어질 때, 1번 컴퓨터가
바이러스에 걸려 이와 연결된 컴퓨터들 또한 바이러스에 감염이 될 것이다.
바이러스에 감염된 컴퓨터의 수를 구하시오.

# 🚥 문제접근

dfs나 bfs로 1번 컴퓨터와 연결된 정점들과 연결된 다른 정점들을 탐색합니다.

**사용하는 자료 구조:**

2차원 배열을 사용하여 그래프를 표현합니다.

## 🌏 풀이

```c
#include<stdio.h>
#include<stdlib.h>
#include<stdint.h>

typedef struct { 
    int32_t** graph;
    int32_t* neighbors;
    int32_t* count;
    int32_t* visited;
    int32_t* N;
} Graph;

int32_t dfs(Graph* a, int32_t R) {
    if ((*a).visited[R]) {
        return 0;
    }
	if (R != 1) {
		*(*a).count += 1;
	}

    *((*a).visited + R) = 1;

    for (int32_t i = 0; i < (*a).neighbors[R]; i += 1) {
        if (!(*a).visited[a->graph[R][i]]) {
            dfs(a, a->graph[R][i]);
        }
    }

    return 0;
}

int32_t main(void) {
    int32_t N, M;
	scanf("%d %d", &N, &M);
    Graph a = {
        (int32_t**)malloc((N + 1) * sizeof(int32_t*)),
        (int32_t*)calloc((N + 1), sizeof(int32_t)),
        (int32_t*)calloc(1, sizeof(int32_t)),
        (int32_t*)calloc((N + 1), sizeof(int32_t)),
        &N,
    };

    for (int32_t i = 0; i < M; i += 1) {
        int32_t u, v;
        scanf("%d %d", &u, &v);

        a.graph[u] = (int32_t*)realloc(a.graph[u], ((a.neighbors[u] + 1) * sizeof(int32_t)));
        a.graph[v] = (int32_t*)realloc(a.graph[v], ((a.neighbors[v] + 1) * sizeof(int32_t)));
        
        a.graph[u][a.neighbors[u]++] = v;
        a.graph[v][a.neighbors[v]++] = u;
    }
    dfs(&a, 1);
    printf("%d\n", *(a.count));
    return 0;
}
```
