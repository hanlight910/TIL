---
id: "25682"
aliases: []
tags: []
---

# Reflection

## 💳 문제풀이

M x N 체스판, 메트릭스가 주어졌을 때 각 칸이
휜색과 검은색이 번갈아서 칠해져 있어야 합니다. 이때,  K x K 부분 메트릭스를 잘랐을 때, 
추가적으로 칠해야 할 때 최소 횟수를 구하세요.

## 🚥 문제접근

이중 루프를 사용해 K x K 부분 메트릭스를 순회하여 첫번째 시작이 휜색과 검은색
번갈아가면서 횟수를 구해서 저장할 때, 시간 복잡도: $O(n \times (K \times K \times 2))$가 나오므로
매우 비효율적입니다.

DP를 사용한 다른 방법을 찾아보겠습니다.
최소 $O(n)$
최새 $O(n \times m)$

### 1️⃣  문제풀이

<style>
    .chessboard {
        display: grid;
        grid-template-columns: repeat(4, 50px);
        grid-template-rows: repeat(4, 50px);
        width: 200px;
        height: 200px;
        border: 2px solid black;
        margin: 20px;
    }
    
    .chessboard-expanded {
        display: grid;
        grid-template-columns: repeat(5, 50px);
        grid-template-rows: repeat(5, 50px);
        width: 200px;
        height: relative;
        border: 2px solid black;
        margin: 20px;
    }
    
    .square {
        display: flex;
        width: 50px;
        border: 1px solid gray;
        height: 50px;
        justify-content: center;
        align-items: center;
    }
    .black {
        background-color: black;
    }
    .white {
        background-color: white;
    }

    .light-pink {
        background-color: #E5CCFF;
        font-weight: bold;
        color: #404040;

    }
    .index {
        background-color: #3333FF;
        content: "1 hello";
    }


</style>


<div class="chessboard" id="chessboard">
    <div class="square black"></div>
    <div class="square black"></div>
    <div class="square black"></div>
    <div class="square black"></div>
    <div class="square black"></div>
    <div class="square black"></div>
    <div class="square black"></div>
    <div class="square black"></div>
    <div class="square black"></div>
    <div class="square black"></div>
    <div class="square black"></div>
    <div class="square white"></div>
    <div class="square black"></div>
    <div class="square black"></div>
    <div class="square white"></div>
    <div class="square black"></div>
</div>



현재 표에서 알 수 있는 건 K x K 부분 메트릭스에 적어도 휜색, 검은색의 수를 기반으로
최소 칠해야 하는 수를 추측하는 것은 어려울 거 같습니다.

<div class="chessboard" id="chessboard">
    <div class="square black"></div>
    <div class="square black"></div>
    <div class="square black"></div>
    <div class="square black"></div>
    <div class="square black"></div>
    <div class="square white"></div>
    <div class="square black"></div>
    <div class="square white"></div>
    <div class="square black"></div>
    <div class="square black"></div>
    <div class="square black"></div>
    <div class="square white"></div>
    <div class="square black"></div>
    <div class="square black"></div>
    <div class="square white"></div>
    <div class="square black"></div>
</div>


적어도 휜색이 4개여도, 정렬되어 있지 않으면, 4번을 칠해야 하는데,

휜색이 1개여도 4번을 칠해야 되고, 휜색이 3개라도 3번을 칠해야 되기 때문에,

얼마나 잘 정렬 되 있는지에 따라서 횟수가 변하므로, 숫자는 큰 영향이 있지는 않을 거 같습니다.

그러면 각 타일을 일일이 비교해야 된다는 소리입니다.

절대적인 두 가지 경우의 수,  왼쪽 위에 끝에 부분이 휜색, 혹은 검은색으로 시작합니다.

#### 1. 두개의 메트릭스 누적합 구하기

두 개의 정렬된 체스보드를 기반으로 비교하여 각각의 칠해야 하는 횟수를

메트릭스 누적합 에 저장하겠습니다.

- 정렬된 휜색:
<div class="chessboard" id="chessboard">
    <div class="square white"></div>
    <div class="square black"></div>
    <div class="square white"></div>
    <div class="square black"></div>
    <div class="square black"></div>
    <div class="square white"></div>
    <div class="square black"></div>
    <div class="square white"></div>
    <div class="square white"></div>
    <div class="square black"></div>
    <div class="square white"></div>
    <div class="square black"></div>
    <div class="square black"></div>
    <div class="square white"></div>
    <div class="square black"></div>
    <div class="square white"></div>
</div>

- 정렬된 검은색:
<div class="chessboard" id="chessboard">
    <div class="square black"></div>
    <div class="square white"></div>
    <div class="square black"></div>
    <div class="square white"></div>
    <div class="square white"></div>
    <div class="square black"></div>
    <div class="square white"></div>
    <div class="square black"></div>
    <div class="square black"></div>
    <div class="square white"></div>
    <div class="square black"></div>
    <div class="square white"></div>
    <div class="square white"></div>
    <div class="square black"></div>
    <div class="square white"></div>
    <div class="square black"></div>
</div>

위에 패턴은 시작이 휜색일 경우 홀수 인덱스별로 계산하면 될 거 같습니다.

편의를 위해 x, y 축 층을 하나 늘리게습니다.

<div class="chessboard-expanded" id="chessboard">
    <div class="square index"> <span>0</span></div>
    <div class="square index"> <span>0</span></div>
    <div class="square index"> <span>0</span></div>
    <div class="square index"> <span>0</span></div>
    <div class="square index"> <span>0</span></div>
    <div class="square index"> <span>0</span></div>
    <div class="square black"></div>
    <div class="square black"></div>
    <div class="square black"></div>
    <div class="square black"></div>
    <div class="square index"> <span>0</span></div>
    <div class="square black"></div>
    <div class="square black"></div>
    <div class="square black"></div>
    <div class="square black"></div>
    <div class="square index"> <span>0</span></div>
    <div class="square black"></div>
    <div class="square black"></div>
    <div class="square black"></div>
    <div class="square white"></div>
    <div class="square index"> <span>0</span></div>
    <div class="square black"></div>
    <div class="square black"></div>
    <div class="square white"></div>
    <div class="square black"></div>
</div>

메트릭스, 2차원 배열의 누계합의 공식은, 인덱스[x, y] 기준

- 휜색으로 시작할 경우:
    - x가 가 홀수, y가 홀수 아니면 x가 짝수, y 가 짝수
    - 현재 색깔이 위에 경우와 같은 지 비교,
    - 같으면 0, 다르면 1
- 검정색으로 시작할 경우:
    - 같은 조건

$$ 누계합[x, y]  = 현재\ 값[x, y] + 누계합[x - 1, y] + 누계합[x, y - 1]
- 누계합[x - 1, y - 1]$$

x, y 행과 열을 늘린 이유는 x, y가 0일 때 앞(-1)이 없기 때문에 0인덱스에
0값을 초기화 해줍니다.

- 참고: [누계합](https://jih3508.tistory.com/50)


#### 2. K x K 부분 메트릭스 비교

K x K에 해당되는 모든 메트릭스를 N x M 메트릭스에서 추출한 부분 구간
최소 값이 곧 칠해야 되는 최소 값입니다.

> 왜냐면 숫자가 클수록 정렬된 체스보드와 같지 않기 때문입니다.

- x의 인덱스 시작은 K 
- y의 인덱스 시작도 동일하게 K
- x, y를 N 까지 수행합니다.

<div class="chessboard-expanded" id="chessboard">
    <div class="square index"> <span>0</span></div>
    <div class="square index"> <span>1</span></div>
    <div class="square index"> <span>2</span></div>
    <div class="square index"> <span>3</span></div>
    <div class="square index"> <span>4</span></div>
    <div class="square index"> <span>1</span></div>
    <div class="square light-pink"><span>i, h</span></div>
    <div class="square light-pink"></div>
    <div class="square light-pink"></div>
    <div class="square black"></div>
    <div class="square index"> <span>2</span></div>
    <div class="square light-pink"></div>
    <div class="square light-pink"></div>
    <div class="square light-pink"></div>
    <div class="square black"></div>
    <div class="square index"> <span>3</span></div>
    <div class="square light-pink"></div>
    <div class="square light-pink"></div>
    <div class="square light-pink"><span>x, y</span></div>
    <div class="square white"></div>
    <div class="square index"> <span>4</span></div>
    <div class="square black"></div>
    <div class="square black"></div>
    <div class="square white"></div>
    <div class="square black"></div>
</div>

<div class="chessboard-expanded" id="chessboard">
    <div class="square index"> <span>0</span></div>
    <div class="square index"> <span>1</span></div>
    <div class="square index"> <span>2</span></div>
    <div class="square index"> <span>3</span></div>
    <div class="square index"> <span>4</span></div>
    <div class="square index"> <span>1</span></div>
    <div class="square black"></div>
    <div class="square light-pink"><span>i, j</span></div>
    <div class="square light-pink"></div>
    <div class="square light-pink"></div>
    <div class="square index"> <span>2</span></div>
    <div class="square black"></div>
    <div class="square light-pink"></div>
    <div class="square light-pink"></div>
    <div class="square light-pink"></div>
    <div class="square index"> <span>3</span></div>
    <div class="square black"></div>
    <div class="square light-pink"></div>
    <div class="square light-pink"></div>
    <div class="square light-pink"><span>x, y</div>
    <div class="square index"> <span>4</span></div>
    <div class="square black"></div>
    <div class="square black"></div>
    <div class="square white"></div>
    <div class="square black"></div>
</div>

etc...

**공식:**
$$구간합[i\sim x, j\sim y] = 누계합[x, y] - 누계합[i - 1, y] + 누계합[x, j - 1]
+ 누계합[i - 1][j - 1]$$

각 구간의 누계합 중 최소 값을 구하면 됩니다.

#### source code

```py
import sys;

inputed: list[str] = list(sys.stdin.readline().rstrip().split());
N: int = int(inputed[0]);
M: int = int(inputed[1]);
K: int = int(inputed[2]);

chess_board: list[list[str]] = [["1" for _ in range(0, M)] for _ in range(0, N)];

for i in range(0, N):
    inputed: list[str] = list(sys.stdin.readline().rstrip());
    for j in range(0, M):
        chess_board[i][j] = inputed[j];

prefix_sum_white: list[list[int]] = [[0 for _ in range(0, M + 1)] for _ in range(0, N + 1)];
prefix_sum_black: list[list[int]] = [[0 for _ in range(0, M + 1)] for _ in range(0, N + 1)];

for i in range(1, N + 1):
    for j in range(1, M + 1):
        white_not_match: int = 0;
        black_not_match: int = 0;
        if (i % 2 == 0 and j % 2 != 0) or (i % 2 != 0 and j % 2 == 0):
            if chess_board[i - 1][j - 1] == "W":
                white_not_match = 1;
            else:
                black_not_match = 1;
        else:
            if chess_board[i - 1][j - 1] == "W":
                black_not_match = 1;
            else:
                white_not_match = 1;

        prefix_sum_black[i][j] = black_not_match + prefix_sum_black[i - 1][j] + prefix_sum_black[i][j - 1] \
            - prefix_sum_black[i - 1][j - 1];
        prefix_sum_white[i][j] = white_not_match + prefix_sum_white[i - 1][j] + prefix_sum_white[i][j - 1] \
            - prefix_sum_white[i - 1][j - 1];

min_count: int = prefix_sum_white[K][K];

for x in range(K, N + 1):
    for y in range(K, M + 1):
        i: int = x - K + 1;
        j: int = y - K + 1;

        black_count: int = prefix_sum_black[x][y] - prefix_sum_black[i - 1][y]\
            - prefix_sum_black[x][j - 1] + prefix_sum_black[i - 1][j - 1];
        white_count: int = prefix_sum_white[x][y] - prefix_sum_white[i - 1][y]\
            - prefix_sum_white[x][j - 1] + prefix_sum_white[i - 1][j - 1];

        if white_count > black_count:
            if min_count > black_count:
                min_count = black_count;
        else:
            if min_count > white_count:
                min_count = white_count

print(min_count);
```
