---
id: "3015"
aliases:
  - 오아시스 재결합
tags:
  - 오아시스 재결합
  - 스택
ref:
  - https://www.acmicpc.net/problem/3015
---

# 💳 문제이해

정수 N 개로 주어진 줄에 서 있는 사람의 키가 주어졌을 때, 서로 볼 수 있는
쌍의 수를 구하는 프로그램을 작성하시오.

# 🚥 문제접근


> "A와 B가 서로 볼 수 있으려면, 두 사람 사이에 A 또는 B보다 키가 큰 사람이 
없어야 한다."

A와 B 서로 볼 수 있는 조건은

A와 B 사이에 더 큰 수가 없어야 합니다.

**볼 수 없는 경우**

- 1 3 2
    - 1과 2는 서로 볼 수 없습니다.
- 1 2 3
    - 1과 3은 서로 볼 수 없습니다.  
    1이 2에 가려져 있기 때문에, 1은 3을 볼 수 있을지 몰라도, 
    3은 1을 볼 수 없습니다.
- 3 2 1
    - 3과 1은 서로 볼 수 없습니다.  
    1이 2에 가려져 있기 때문에, 1은 3을 볼 수 있을지 몰라도, 
    3은 1을 볼 수 없습니다.

**볼 수 있는 경우**

- 2 1 3
    - 2와 3은 서로를 볼 수 있습니다.  
    사이에 있는 1은 2와 3보다 작습니다.
- 3 1 2
    - 3과 2는 서로를 볼 수 있습니다.  
    사이에 있는 1은 2와 3보다 작습니다.
- 2 2 3
    - 끝에 있는 2와 3은 서로를 볼 수 있습니다.  
    조건 상 볼 수 있다고 합니다.

> "1 2 2 는 볼 수 없습니다."
- ==1 2 2==
    - 끝에 있는 1과 2는 서로를 볼 수 있습니다.
    조건 상 볼 수 있다고 합니다.

문제를 더 알기 위해, 예시 케이스를 파보겠습니다.

## 🌏 예제

`2 4 1 2 2 5 1`

1. 2가 들어옵니다.
    - 비교할 대상이 없습니다.
2. 4가 들어옵니다.
    - 4는 2보다 큽니다. 둘은 서로를 볼 수 있습니다.
    - 쌍의 수: 1
3. 1이 들어왔습니다.
    - 1은 4보다 작습니다. 둘은 서로를 볼 수 있습니다.
    - 쌍의 수: 2
4.  2가 들어옵니다.
    - 2는 1보다 큽니다. 둘은 서로를 볼 수 있습니다.
    - 2와 4사이에 있는 1은 2와 4보다 작습니다 둘은 서로를 볼 수 있습니다.
    - 쌍의 수: 4

> "5번 예제를 잘 못 계산했습니다. 2와 1은 서로 볼 수 없습니다. 2와 4가 서로를
볼 수 있습니다."
5. 2가 들어옵니다.
    - 2는 2랑 같습니다. 둘은 서로를 볼 수 있습니다.
    - 2와 1사이에 2가 있지만, 이는 2보다 크지 않으므로 서로를 볼 수 있습니다.
    - 쌍의: 6
6. 5가 들어옵니다.
    - 5는 2보다 큽니다. 둘은 서로를 볼 수 있습니다.
    - 5와 2사이에 2가 있지만, 2를 초과하지 않으므로, 둘은 서로를 볼 수 있습니다.
    - 1은 5를 볼 수 있지만, 5는 2에 가려져 1을 볼 수 있습니다.
    - 5와 4 사이에, 더 큰 수는 없으니 서로를 볼 수 있습니다.
    - 쌍의 수:  9
7. 1이 들어옵니다.
    - 1은 5보다 작습니다. 둘은 서로를 볼 수 있습니다.
    - 쌍의 수: 10

## 🛠️ 분석
여기설 알 수 있는 사실은 이전 원소가 현재 워소보다 작을 경우
현재 원소의 의해 이전 원소들은 가려지므로, 더 이상 필요가 없습니다.
고로 제거합니다.

> 1 < 2 < 3 (1, 2는 이제 필요 없음)

반대로 현재 원소가 이전 원소보다 작으면 어떻게 할까요?
쌍의 개수만 추가하고 다음 원소를 받습니다.

- 예시 프로그램을 작성하고, 테스트 해보겠습니다.

### ⁉️  오류 

> "이 부분에서 하는 말은 전부 거짓입니다."

테스트 케이스 중 1 2 2 가 있었습니다.
이는 맨 끝에 있는 1과 2는 서로 볼 수 있었습니다 고로 1을 제거하면 안 됩니다.

이는 같은 키를 가진 수들이 존재하므로 예의적으로 처리해야 합니다.

1 2 2를 어떻게 처리해야 할 것인가...

2 다음 원소를 확인하면 될까 싶지만, 2의 개수를 확인 할 수 없는 이상,
다음 원소를 확인하는 방식은 적절하지 않습니다.

> 1 < 2 < 2 < 2 ...

반대로 2의 개수를 확인할 수 있다면, 적절한 대응을 할 수 있을 거 같습니다.

1 < 2 < 2 < 2 

1. 1이 들어옵니다.
2. 2는 1보다 큽니다. 1은 2의 가려져 보지 못합니다.(그 다음이 2이면, 볼 수 있습니다.)
    - 쌍의 개수: 1
3. 2와 2는 같습니다.
    - 같으면 조건 상, 쌍의 개수에 추가합니다.
    - 다만 그 이전에 1도 있으므로 하나 더 추가합니다.
    - 2의 개수를 늘립니다.  
    이는 2의 개수가 늘어나면, 그 만큼 조합이 많아지기 때문입니다.
    - 그리고 2를 제거합니다.
    - 2의 개수: 2
    - 쌍의 개수: 3
4. 2와 2는 같습니다.
    - 그 이전 이전 1도 있으므로 하나 더 추가합니다.
    - 2의 개수를 쌍의 개수에 추가합니다.  
    이는 첫 번째 2와 현재 2, 두 번째 2와 현재 2의 쌍입니다.
    (2(1), 2(3)), (2(2), 2(3))
    - 쌍의 개수: 6

결국에는 안 풀려서, 정답지를 보고 풀었습니다.

## ☠️  정답

좀 헷갈렸던 부분이 조건이 사이에 어느 한 쪽이라도 더 큰게 있더라도 다른 한 쪽이
같으면 보일 줄 알았는데 아니네요, 말 그대로 a 와 b 사이에 자기보다 더 큰 게 없어야
합니다.

헷갈리니까 정리를:

- 1 2 2에서는 마지막 1과 2는 서로를 볼 수 없는데.
- 1 1 2에서는 마지막 1과 2는 서로를 볼 수 있습니다.

여기서 A와 B 사이에 A 또는 B 보다 큰 키가 없다 라는 조건을 만족합니다.

- 1 2 2 5 에서는 5와 1이 서로 볼 수 없습니다. 반면 첫 번째 2와 5는 서로를
볼 수 있습니다.

이러면, 무작정 쌍의 개수에 +1을 하면 안 되겠죠, 1 < 2 < 2 마지막 2는 1을 볼 수 
없으니, +1을 하는 경우는 2보다 더 큰 경우, 즉 스택에 개수가 1개 보다 큰 경우입니다.

3 < 2 < 2: 3은 2보다 커서 제거하지 않습니다. 첫 번째 2를 제거하면 스택 원소의
개수는 2 이상입니다.

2 < 2 < 5: 와 같이 5입장에서는 2를 봤다는 걸 어떻게 증명하고 쌍의 개수를 늘릴까요?

이는 간단한 수학으로 해결 할 수 있습니다. 

- 2 < 2 < 2 < 5  
2 번째 2는 2가 2번 중복된다는 사실을 3 번째 2에게 넘깁니다. 
3 번째 2 입장에서 첫 번째 2와 두 번째 2를 서로 볼 수 있으니 쌍의 
개수의 2를 추가해야 합니다. 고로 넘겨 받은 2의 쌍의 개수의 더합니다.
마찬가지로 다음 원소에 해당 중복 된 개수에 1을 더하고
를 넙깁니다. 5 또한 나머지 2들을 볼 수 있습니다. 2의 개수는 3이니,
2의 개수인 3을 쌍의 개수에 더해 줍니다.

### 🖥️ source code

```c
#include<stdio.h>
#include<stdint.h>
#include<stdlib.h>

typedef struct {
	int32_t val;
	int32_t count;
} pair;

typedef struct {
	pair* arr;
	int32_t top_idx;
} stack;

int32_t is_empty(stack a) {
    return a.top_idx > -1 ? 0 : 1; 
}

int32_t push(stack* a, int32_t value, int32_t cnt_height) {
    a->arr[a->top_idx + 1].val = value; 
    a->arr[a->top_idx + 1].count = cnt_height;
    a->top_idx += 1;
    return 0;
}

int32_t pop(stack* a) {
    a->top_idx -= 1;
    return 0;
}

int32_t peek(stack a) {
    return a.arr[a.top_idx].val;
}

int64_t get_joint_count(int32_t* arr, int32_t length) {
	stack a = {
		.arr = (pair*)malloc(length * sizeof(pair)),
        .top_idx = -1,
	};


    int64_t joint_count = 0;
	int32_t current_count = 1;
    a.arr[0].val = 0;
	a.arr[0].count = 1;
    a.top_idx = 0;
    for (int32_t i = 1; i < length; i += 1) {
		current_count = 1;
        while (!is_empty(a) && arr[peek(a)] < arr[i]) {
			joint_count += 1;
			pop(&a);
        }
		if (!is_empty(a)) {
			if (arr[peek(a)] == arr[i]) {
				joint_count += a.arr[a.top_idx].count;
				current_count = a.arr[a.top_idx].count + 1;

				if (a.top_idx > 0) {
					joint_count += 1;	
				}
			} else if (arr[peek(a)] > arr[i]) {
				joint_count += 1;
			}

        }
        push(&a, i, current_count);
    }

	return joint_count;
}
int32_t main(void) {
	int32_t n;
	scanf("%d", &n);
	int32_t arr[n];
	for (int32_t i = 0; i < n; i += 1) {
		scanf("%d", arr + i);
	}
	int64_t joint_count = get_joint_count(arr, n);
	printf("%ld\n", joint_count);
	
	return 0;
}
```
