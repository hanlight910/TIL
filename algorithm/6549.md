---
id: "6549"
aliases: []
tags: []
---

# 💳 문제이해

여러개의 테스트 케이스가 주어집니다.
N개의 직사각형이 주저졌을 때, 각 직사각형의 높이가 주어집니다.
각 직사각형의 너비는 모두 1입니다. 각 직사각형이 한줄로 나열되어 있을 때,
가장 큰 넓이(Area)를 가진 직사각형을 구하세요.

# 🚥 문제접근

높이(height)가 최대 $1\times 10^9$입니다.


<style>
    .container {
        display: flex;
        align-items: flex-end; /* 직사각형들을 아래쪽에 정렬 */
        height: 300px; /* 전체 그래프 높이 */
        border: 1px solid #333;
    }
    .bar {
        width: 20px; /* 모든 직사각형의 너비 */
        margin-right: 5px; /* 직사각형 사이의 간격 */
        background-color: #4CAF50;
        display: inline-block;
        display: flex;
        color: black;
        margin: 5px;
    }
    /* 예제 직사각형들의 높이 */
    .bar-1 { height: 50px; }
    .bar-2 { height: 100px; }
    .bar-3 { height: 150px; }
    .bar-4 { height: 200px; }
    .bar-5 { height: 250px; }
</style>

<div class="container">
    <div class="bar bar-1">1</div>
    <div class="bar bar-2">2</div>
    <div class="bar bar-3">3</div>
    <div class="bar bar-4">4</div>
    <div class="bar bar-5">5</div>
    <div class="bar bar-3">3</div>
</div>


위에 직사각형들의 나열을 보면, 3 x 4 = 12가 가장 큰 넓이를 가질 수 있다는
것을 알 수 있습니다. 그러면 어떻게 컴퓨터는 해당 직사각형이 가장 큰 
넓이인 것을 알 수 있을까요?

적어도 1부터 5까지 오름차순으로 나열되어 있으면, 마지막 원소 5를 기준을 직전


## 1️⃣  문제풀이

### source code

```c
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>

#define get_max(a, b) ((a) > (b) ? (a) : (b))

typedef struct {
    int32_t* data;
    int32_t top;
} stack;

int32_t input_height(int32_t** height) {
    int32_t length;
    scanf("%d", &length);

    if (length == 0) {
        return 0;
    } else {
        *height = (int32_t*)malloc(length * sizeof(int32_t));
        if (*height == NULL) {
            fprintf(stderr, "Memory allocation failed\n");
            exit(EXIT_FAILURE);
        }

        for (int32_t i = 0; i < length; i++) {
            scanf("%d", &((*height)[i]));
        }

        return length;
    }
}

void push(stack* s, int32_t value) {
    s->data[++(s->top)] = value;
}

void pop(stack* s) {	
    if (s->top != -1) {
        s->top--;
    }
}

int32_t peek(stack* s) {
    return s->data[s->top];
}

int64_t get_area(stack* s, int32_t* heights, int32_t index) {
    int32_t top_of_stack = s->data[s->top];
    pop(s);
    int32_t height = heights[top_of_stack];
    int32_t width = (s->top != -1) ? (index - s->data[s->top] - 1) : index;
    return (int64_t)height * width;
}

void print_max_area(int32_t* height, int32_t length) {
    int32_t index = 0;
    stack s;
    s.data = (int32_t*)malloc(length * sizeof(int32_t));
    if (s.data == NULL) {
        fprintf(stderr, "Memory allocation failed\n");
        exit(EXIT_FAILURE);
    }
    s.top = -1;
    
    int64_t max_area = 0;
    while (index < length) {
        if (s.top == -1 || height[peek(&s)] <= height[index]) {
            push(&s, index);
            index++;
        } else {
            int64_t area = get_area(&s, height, index);
            max_area = get_max(max_area, area);
        }
    }

    while (s.top != -1) {
        int64_t area = get_area(&s, height, index);
        max_area = get_max(max_area, area);
    }

    printf("%lld\n", max_area);
    free(s.data);
}

int32_t main(void) {
    while (1) {
        int32_t* height;
        int32_t length = input_height(&height);

        if (length == 0) {
            break;
        }
        print_max_area(height, length);
        free(height);
    }
    return 0;
}


```
