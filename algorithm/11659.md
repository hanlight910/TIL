---
id: "11659"
aliases: []
tags: []
---

# Reflection

## 💳 문제 이해

길이 N의 수열이 주어졌을 때, 구간별 합계를 횟수 M번 만큼 구합니.
구간 i 부터 j가 M번 주어지면, i번째 수부터 j번 째 수까지 합을 출력하세요.

## 🚥 문제 접근

갯수만큼 루프를 돌리고 인덱스마다 계산 하면 될 거 같지만, N과 M의 최대 값이 100,000
이되면 최악의 경우 시간복잡도가 $(O(n^2)$가 되므로 너무 느려서 동적 프로그래밍
사용하여 우선 1부터 n까지 각 구간별로 최대 합을 구한 다음에, 각 구간별로 최대합
데이터를 조회하여 계산하는 것이 좋을 거 같습니다. 이러면 시간복잡도$(O(n || m))$

### 1️⃣  문제풀이

1부터 n까지 순회를 돌며 각 요소마다 최대 합을 구합니다.

- sum_array[1] = 1;
- sum_array[2] = 1 + 2;
- sum_array3 = 1 + 2 + 3;
...

이런 식으로

다 더하면

각 구간을 순회하여 계산합니다.

- 구간합은 = i 부터 j까지의 합
- 구간합은 = {1~j 까지의 최대 합} - {1 ~ (i - 1)까지의 최대 합}
    - i 가 1이면 첫번째 요소인 걸 의미하기 때문에 오른쪽 수식 값을 0으로 계산합니다.

**공식**:
> 합계배열 인덱스 시작이 0이 아니라 1일 경우
- a = 합계배열[j]
- b = 만약에 i 가 0일 경우 
    - 0
    - 아니면 합계배열[i - 1]
- 구간합 = a - b
    
#### source code

```c
// c language
#include<stdio.h>
#include<stdint.h>
#include<stdlib.h>

int64_t* get_maximum_of_index(int32_t sequence[], int64_t length) {
    int64_t* return_value = NULL;

    int64_t* max_sum_of_index_array = (int64_t*)malloc(length * sizeof(int64_t));

    max_sum_of_index_array[0] = sequence[0];
    for (int32_t index = 1; index < length; index += 1) {
        int32_t num = sequence[index] + sequence[index - 1];
        max_sum_of_index_array[index] = num;
    }

    return_value = max_sum_of_index_array;
    return return_value;
}

typedef struct Interval {
    int32_t i;
    int32_t j;
} Interval;

int32_t print_sum_of_m_elements(Interval m[], int64_t max_sum_of_index_array[], int32_t length) {
    int32_t return_value = 0;

    for (int32_t index = 0; index < length; index += 1) {
        int32_t a = max_sum_of_index_array[m[index].j - 1];

        // 첫번째 요소로 시작하면, 뺄 값이 없습니다.
        int32_t b = m[index].i - 1 - 1 < 0 ? 0 : max_sum_of_index_arrya[m[index].i - 1 - 1];
        int32_t sum = a - b;
        printf("%d\n", sum);
    }

    return return_value;
}
```
