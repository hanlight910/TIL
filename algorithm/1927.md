---
id: "1927"
aliases: []
tags: []
ref: []
---

# 💳 문제이해

자연수 N개가 주어졌을 때, 해당 자연수가 0이면 주어진 자연수 중
가장 작은 값을 내보냅니다.

# 🚥 문제

선형 탐색은 정렬되지 않은 배열에서 가장 빠르게 찾을 수 있는 방법이지만,
자주 최소값을 찾기에는 매번 N번 탐색하기에는 비효율적이므로 적합하지 않습니다.

정렬을 한다고 해도 원소의 삽입/삭제가 빈번히 일어나기 때문에, 적합하지 않습니다.

그러면 최대값/최소값을 자주 찾고, 삽입과 삭제가 빈번히 일어나는 경우 힙 정렬이
적합합니다.


## 💡 문제풀이
1. 노드 추가
    - 자식 노드에 삽입
    - 부모 노드가 자식 노드보다 클 경우 교환
        - 이를 루트 노드까지 실행

2. 루트 노드 내보내기
    - 루트 노드 반환
    - 루트 노드에 마지막 자식 노드 삼입
    - 부모 노드를 자식 노드들보다 클 경우 교환합니다.
        - 이를 마지막 자식 노드까지 실행합니다.

### 🖥️ source code

```c
#include<stdio.h>
#include<stdint.h>
#include<stdlib.h>

typedef struct {
	int32_t* arr;
	int32_t size;
} heap;

void insert(heap* a, int32_t value) {
	a->arr[a->size] = value;
	a->size += 1;
	return;
}

void swap(int32_t* a, int32_t* b) {
	int32_t temp = *a;
	*a = b[0];
	*b = temp;
	return;
}

void heapify_up(heap* a) {
	if (a->size <= 1) {
		return;
	}

	int32_t child_node = a->size - 1;
	int32_t parent_node = 0;
		
	do{
		parent_node = (child_node - 1) / 2;

		if (a->arr[parent_node] > a->arr[child_node]) {
			swap(&a->arr[parent_node], &a->arr[child_node]);
			child_node = parent_node;
		} else {
			break;
		}
	} while (child_node > 0);

	return;
}

void heapify_down(heap* a) {
	if (a->size <= 1) {
		return;
	}


	int32_t parent_node = 0;

	while (parent_node < a->size) {
		int32_t min_node = parent_node;
		int32_t left_node = (parent_node * 2) + 1;
		int32_t right_node = (parent_node * 2) + 2;	
		if (left_node < a->size && a->arr[left_node] < a->arr[min_node]) {
			min_node = left_node;	
		}
		if (right_node < a->size && a->arr[right_node] < a->arr[min_node]) {
			min_node = right_node;
		}

		if (min_node != parent_node) {
			swap(&a->arr[parent_node], &a->arr[min_node]);
			parent_node = min_node;
		} else {
			break;
		}
	}
	return;
}

int32_t extract_min_value(heap* a) {
	if (a->size == 0) {
		return 0;
	}

	int32_t min_value = a->arr[0];
	a->arr[0] = a->arr[a->size - 1];
	a->size -= 1;

	heapify_down(a);
	return min_value;
}


int32_t main(void) {
	int32_t n;
	scanf("%d", &n);

	int32_t inputed[n];
	for (int i = 0; i < n; i += 1) {
		scanf("%d", &inputed[i]);
	}
	
	heap a = {
		(int32_t*)calloc(n, sizeof(int32_t)),
		0,
	};

	for (int i = 0; i < n; i += 1) {
		if (inputed[i] == 0) {
			int32_t min_value = extract_min_value(&a);
			printf("%d\n", min_value);
		} else {
			insert(&a, inputed[i]);
			heapify_up(&a);
		}
	}
	
	return 0;
}
```

# 🔗 ref
- [백준/1927](https://www.acmicpc.net/problem/1927)
